[["index.html", "Workshop 5: Programming in R QCBS R Workshop Series Preface 0.1 Code of conduct 0.2 Contributors 0.3 Contributing", " Workshop 5: Programming in R QCBS R Workshop Series Developed and maintained by the contributors of the QCBS R Workshop Series1 2021-07-30 21:33:41 Preface The QCBS R Workshop Series is a series of 10 workshops that walks participants through the steps required to use R for a wide array of statistical analyses relevant to research in biology and ecology. These open-access workshops were created by members of the QCBS both for members of the QCBS and the larger community. The content of this workshop has been peer-reviewed by several QCBS members. If you would like to suggest modifications, please contact the current series coordinators, listed on the main Github page. 0.1 Code of conduct The QCBS R Workshop Series and the QCBS R Symposium are venues dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. Participants, presenters and organizers of the workshop series and other related activities accept this Code of Conduct when being present at any workshop-related activities. We do not tolerate behaviour that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. 0.1.1 Expected behaviour All participants are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members 0.1.2 Unacceptable behaviour Examples of unacceptable behaviour by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the - basis of membership of any specific group; causing someone to fear for their safety, such as through stalking or intimidation; violent threats or language directed against another person; the display of sexual or violent images; unwelcome sexual attention; nonconsensual or unwelcome physical contact; insults or put-downs; sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes; incitement to violence, suicide, or self-harm; continuing to initiate interaction (including photography or recording) with - someone after being asked to stop; publication of private communication without consent. 0.2 Contributors Originally developed by: Contributed with changes to the presentation: Contributed with changes to the written material: Contributed by reporting issues and suggesting modifications: 0.3 Contributing Under construction. The QCBS R Workshop Series is part of the Québec Centre for Biodiversity Science, and is maintained by the series coordinators and graduent student, postdoctoral, and research professional members. The contributors for this workshop can be accessed here.↩︎ "],["learning-objectives.html", "Chapter 1 Learning objectives", " Chapter 1 Learning objectives Summary: This workshop focuses on basic programming in R. In this workshop, you will learn how to use control flow (for loops, if, while) methods to prevent code repetition, facilitate organization and run simulations. In addition, you will learn to write your own functions, and tips to program efficiently. The last part of the workshop will discuss packages that will not covered elsewhere in this workshop series, but that may be of interest to participants. Learning what is control flow; Writing your first functions in R Speeding up your code Useful R packages for biologists Include learning objectives. "],["preparing-for-the-workshop.html", "Chapter 2 Preparing for the workshop", " Chapter 2 Preparing for the workshop To prepare for this workshop, you must do the following steps: Download the R script and data required for this workshop: R Script Make sure to load the following packages (see how in the R script): vegan (for multivariate analyses) install.packages(&quot;vegan&quot;) library(vegan) "],["control-flow.html", "Chapter 3 Control Flow 3.1 Representing structure", " Chapter 3 Control Flow Program flow control can be simply defined as the order in which a program is executed. Why is it advantageous to have structured programs? It decreases the complexity and time of the task at hand; This logical structure also means that the code has increased clarity; It also means that many programmers can work on one program. This means increased productivity Flowcharts can be used to plan programs and represent their structure 3.1 Representing structure The two basic building blocks of codes are the following: Selection Program’s execution determined by statements if if else Iteration Repetition, where the statement will loop until a criteria is met for while repeat "],["decision-making.html", "Chapter 4 Decision making 4.1 if statement 4.2 if else statement 4.3 Challenge 1", " Chapter 4 Decision making 4.1 if statement if (condition) { expression } 4.2 if else statement if(condition) { expression 1 } else { expression 2 } What if you want to test more than one condition? if and if else test a single condition You can also use ifelse function to: test a vector of conditions; apply a function only under certain conditions. a &lt;- 1:10 ifelse(a &gt; 5, &quot;yes&quot;, &quot;no&quot;) a &lt;- (-4):5 sqrt(ifelse(a &gt;= 0, a, NA)) Nested if else statement if (test_expression1) { statement1 } else if (test_expression2) { statement2 } else if (test_expression3) { statement3 } else { statement4 } 4.3 Challenge 1 Paws &lt;- &quot;cat&quot; Scruffy &lt;- &quot;dog&quot; Sassy &lt;- &quot;cat&quot; animals &lt;- c(Paws, Scruffy, Sassy) 1.- Use an if statement to print “meow” if Paws is a “cat”. ++++ Challenge 1 : Answer| 2.- Use an if else statement to print “woof” if you supply an object that is a “dog” and “meow” if it is not. Try it out with Paws and Scruffy. 3.- Use the ifelse function to display “woof” for animals that are dogs and “meow” for animals that are cats. ++++ 4.3.1 Beware of R’s expression parsing! Use curly brackets {} so that R knows to expect more input. Try: if (2+2) == 4 print(&quot;Arithmetic works.&quot;) else print(&quot;Houston, we have a problem.&quot;) This doesn’t work because R evaluates the first line and doesn’t know that you are going to use an else statement Instead use: if (2 + 2 == 4) { # &lt;&lt; print(&quot;Arithmetic works.&quot;) } else { # &lt;&lt; print(&quot;Houston, we have a problem.&quot;) } #&lt;&lt; 4.3.2 Remember the logical operators == equal to != not equal to !x not x &lt; less than &lt; = less than or equal to &gt; greater than &gt;= greater than or equal to x &amp; y x AND y x|y x OR y isTRUE(x) test if X is true "],["iteration.html", "Chapter 5 Iteration 5.1 for loop 5.2 for loops within for loops 5.3 Getting better: using the apply() family 5.4 Challenge 2 5.5 Modifying iterations 5.6 Modifying iterations: while 5.7 Challenge 3 5.8 Challenge 4", " Chapter 5 Iteration Every time some operations have to be repeated, a loop may come in handy Loops are good for: doing something for every element of an object doing something until the processed data runs out doing something for every file in a folder doing something that can fail, until it succeeds iterating a calculation until it converges 5.1 for loop A for loop works in the following way: for (val in sequence) { statement } The letter i can be replaced with any variable name and the sequence can be almost anything, even a list of vectors. # Try the commands below and see what happens: for (a in c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programmers&quot;)) { print(a) } for (z in 1:30) { a &lt;- rnorm(n = 1, mean = 5, sd = 2) print(a) } elements &lt;- list(1:3, 4:10) for (element in elements) { print(element) } In the example below, R would evaluate the expression 5 times: for (i in 1:5) { expression } In the example, every instance of m is being replaced by each number between 1:10, until it reaches the last element of the sequence. for (m in 1:10) { print(m * 2) } for (m in 1:5) { print(m * 2) } for (m in 6:10) { print(m * 2) } x &lt;- c(2, 5, 3, 9, 6) count &lt;- 0 for (val in x) { if (val%%2 == 0) { count = count + 1 } } print(count) For loops are often used to loop over a dataset. We will use loops to perform functions on the CO2 dataset which is built in R. data(CO2) # This loads the built in dataset for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset print(CO2$conc[i]) # print the CO2 concentration } for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } Tip 1. To loop over the number of rows of a data frame, we can use the function nrow() for (i in 1:nrow(CO2)) { # for each row in the CO2 dataset print(CO2$conc[i]) # print the CO2 concentration } Tip 2. If we want to perform operations on the elements of one column, we can directly iterate over it for (p in 1:CO2$conc) { # for each row of the column &#39;conc&#39;of the CO2 df print(p) # print the p-th element } Tip 3. The expression within the loop can be almost anything and is usually a compound statement containing many commands. for (i in 4:5) { # for i in 4 to 5 print(colnames(CO2)[i]) print(mean(CO2[, i])) # print the mean of that column from the CO2 dataset } 5.2 for loops within for loops In some cases, you may want to use nested loops to accomplish a task. When using nested loops, it is important to use different variables as counters for each of your loops. Here we used i and n: for (i in 1:3) { for (n in 1:3) { print(i * n) } } 5.3 Getting better: using the apply() family R disposes of the apply() function family, which consists of vectorized functions that aim at minimizing your need to explicitly create loops. apply() can be used to apply functions to a matrix (height &lt;- matrix(c(1:10, 21:30), nrow = 5, ncol = 4)) } apply(X = height, MARGIN = 1, FUN = mean) ?apply 5.3.1 apply() lapply() applies a function to every element of a list. It may be used for other objects like dataframes, lists or vectors. The output returned is a list (explaining the “l” in lapply) and has the same number of elements as the object passed to it. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list lapply(SimulatedData, mean) SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list lapply(SimulatedData, mean) 5.3.2 sapply() sapply() is a ‘wrapper’ function for lapply(), but returns a simplified output as a vector, instead of a list. The output returned is a list (explaining the “l” in lapply) and has the same number of elements as the object passed to it. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list sapply(SimulatedData, mean) 5.3.3 mapply() mapply() works as a multivariate version of sapply(). It will apply a given function to the first element of each argument first, followed by the second element, and so on. For example: lilySeeds &lt;- c(80, 65, 89, 23, 21) poppySeeds &lt;- c(20, 35, 11, 77, 79) # Output mapply(sum, lilySeeds, poppySeeds) 5.3.4 tapply() tapply() is used to apply a function over subsets of a vector. It is primarily used when the dataset contains dataset contains different groups (i.e. levels/factors) and we want to apply a function to each of these groups. head(mtcars) # get the mean hp by cylinder groups tapply(mtcars$hp, mtcars$cyl, FUN = mean) 5.4 Challenge 2 You have realized that your tool for measuring uptake was not calibrated properly at Quebec sites and all measurements are 2 units higher than they should be. 1.- Use a loop to correct these measurements for all Quebec sites. 2.- Use a vectorisation-based method to calculate the mean CO2-uptake in both areas. ++++ Challenge 2 : Answer| 1.-Using for and if to correct the measurements: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$uptake[i] &lt;- CO2$uptake[i] - 2 } } 2.- Using tapply() to calculate the mean for each group: tapply(CO2$uptake, CO2$Type, mean) ++++ 5.5 Modifying iterations Normally, loops iterate over and over until they finish. Sometimes you may be interested in breaking this behaviour. For example, you may want to tell R to stop executing the iteration when it reaches a given element or condition. You may also want R to jump certain elements when certain conditions are met. For this, we will introduce break, next and while. 5.5.1 Modifying iterations: break for (val in x) { if (condition) { break } statement } 5.5.2 Modifying iterations: next for (val in x) { if (condition) { next } statement } Print the $CO_{2}$ concentrations for \"chilled\" treatments and keep count of how many replications were done. count &lt;- 0 for (i in 1:nrow(CO2)) { if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # Skip to next iteration if treatment is nonchilled count &lt;- count + 1 # print(CO2$conc[i]) } print(count) # The count and print command were performed 42 times. sum(CO2$Treatment == &quot;nonchilled&quot;) This could be equivalently written using a repeat loop and break count &lt;- 0 i &lt;- 0 repeat { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) if (i == nrow(CO2)) break # stop looping } print(count) 5.6 Modifying iterations: while This could also be written using a while loop: i &lt;- 0 count &lt;- 0 while (i &lt; nrow(CO2)) { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) } print(count) 5.7 Challenge 3 You have realized that your tool for measuring concentration did not work properly. At Mississippi sites, concentrations less than 300 were measured correctly, but concentrations equal or higher than 300 were overestimated by 20 units! Your mission is to use a loop to correct these measurements for all Mississippi sites. Tip. Make sure you reload the data so that we are working with the raw data for the rest of the exercise: data(CO2) ++++ Challenge 3: Answer|  for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot;) { if (CO2$conc[i] &lt; 300) next CO2$conc[i] &lt;- CO2$conc[i] - 20 } } *Note: We could also have written it in this way, which is more concise and clear* for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot; &amp;&amp; CO2$conc[i] &gt;= 300) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } ++++ 5.7.1 Edit a plot using for and if Let’s plot uptake vs concentration with points of different colors according to their type (Quebec or Mississippi) and treatment (chilled or nonchilled). plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;) } if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;orange&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;green&quot;) } } 5.8 Challenge 4 Generate a plot of showing concentration versus uptake where each plant is shown using a different point. Bonus points for doing it with nested loops! ++++ Challenge 4 Answer | plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 Concentration&quot;, ylab = &quot;CO2 Uptake&quot;) plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } "],["writing-functions.html", "Chapter 6 Writing functions 6.1 Challenge 5 6.2 Default values in a function 6.3 Argument ... 6.4 Return values 6.5 Challenge 6 6.6 Accessibility of variables", " Chapter 6 Writing functions ** Why write functions? ** Much of the heavy lifting in R is done by functions. They are useful for: - Performing a task repeatedly, but configurably; - Making your code more readable; - Make your code easier to modify and maintain; - Sharing code between different analyses; - Sharing code with other people; - Modifying R’s built-in functionality. 6.0.0.1 What is a function? 6.0.0.2 Syntax of a function function_name &lt;- function(argument1, argument2, ...) { expression... # What we want the function to do return(value) # Optional } 6.0.0.3 Arguments of a function function_name &lt;- function(argument1, argument2, ...) { expression... return(value) } Arguments are the entry values of your function and will have the information your function needs to be able to perform correctly. A function can have between 0 and an infinity of arguments. See the following example: operations &lt;- function(number1, number2, number3) { result &lt;- (number1 + number2) * number3 print(result) } operations(1, 2, 3) 6.1 Challenge 5 Using what you learned previously on flow control, create a function print_animal that takes an animal as argument and gives the following results: print_animal &lt;- function(animal) { if (animal == &quot;dog&quot;) { print(&quot;woof&quot;) } else if (animal == &quot;cat&quot;) { print(&quot;meow&quot;) } } Scruffy &lt;- &quot;dog&quot; Paws &lt;- &quot;cat&quot; print_animal(Scruffy) print_animal(Paws) ++++ Challenge 5: Answer | print_animal &lt;- function(animal) { if (animal == &quot;dog&quot;) { print(&quot;woof&quot;) } else if (animal == &quot;cat&quot;) { print(&quot;meow&quot;) } } ++++ 6.2 Default values in a function Arguments can also be optional and be provided with a default value. This is useful when using a function with the same settings, but still provides the flexibility to change its values, if needed. operations &lt;- function(number1, number2, number3 = 3) { result &lt;- (number1 + number2) * number3 print(result) } operations(1, 2, 3) # is equivalent to operations(1, 2) operations(1, 2, 2) # we can still change the value of number3 if needed 6.3 Argument ... The special argument ... allows you to pass on arguments to another function used inside your function. Here we use ... to pass on arguments to plot() and points() plot.CO2 &lt;- function(CO2, ...) { #&lt;&lt; plot(x=CO2$conc, y=CO2$uptake, type=&quot;n&quot;, ...) #&lt;&lt; for (i in 1:length(CO2[,1])){ if (CO2$Type[i] == &quot;Quebec&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;, type = &quot;p&quot;, ...) #&lt;&lt; } else if (CO2$Type[i] == &quot;Mississippi&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;, type = &quot;p&quot;, ...) #&lt;&lt; } } } plot.CO2(CO2, cex.lab=1.2, xlab=&quot;CO2 concentration&quot;, ylab=&quot;CO2 uptake&quot;) #&lt;&lt; plot.CO2(CO2, cex.lab=1.2, xlab=&quot;CO2 concentration&quot;, ylab=&quot;CO2 uptake&quot;, #&lt;&lt; pch=20) #&lt;&lt; The special argument ... allows you to input an indefinite number of arguments. sum2 &lt;- function(...) { # &lt;&lt; args &lt;- list(...) #&lt;&lt; result &lt;- 0 for (i in args) { result &lt;- result + i } return(result) } sum2(2, 3) #&lt;&lt; sum2(2, 4, 5, 7688, 1) #&lt;&lt; 6.4 Return values The last expression evaluated in a function becomes the return value. myfun &lt;- function(x) { if (x &lt; 10) { 0 } else { 10 } } myfun(5) myfun(15) function() itself returns the last evaluated value even without including return() function. It can be useful to explicitly return() if the routine should end early, jump out of the function and return a value. simplefun1 &lt;- function(x) { if (x &lt; 0) return(x) } Functions can return only a single object (and text). But this is not a limitation because you can return a list containing any number of objects. simplefun2 &lt;- function(x, y) { z &lt;- x + y return(list(result = z, x = x, y = y)) } simplefun2(1, 2) 6.5 Challenge 6 Using what you have just learned on functions and control flow, create a function named bigsum that takes two arguments a and b and: Returns 0 if the sum of a and b is strictly less than 50; Else, returns the sum of a and b ++++ Challenge 6 Answer | Answer 1: bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { return(0) } else { return(result) } } Answer 2: bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { 0 } else { result } } 6.6 Accessibility of variables It is essential to always keep in mind where your variables are, and whether they are defined and accessible: Variables defined *inside* a function are not accessible outside of it! Variables defined *outside* a function are accessible inside. But it is NEVER a good idea, as your function will not function if the outside variable is erased. var1 &lt;- 3 # var1 is defined outside our function vartest &lt;- function() { a &lt;- 4 # &#39;a&#39; is defined inside print(a) # print &#39;a&#39; print(var1) # print var1 } a # we cannot print &#39;a&#39; as it exists only inside the function vartest() # calling vartest() will print a and var1 rm(var1) # remove var1 vartest() # calling the function again doesn&#39;t work anymore Use arguments then! Also, inside a function, arguments names will take over other variable names. var1 &lt;- 3 # var1 is defined outside our function vartest &lt;- function(var1) { print(var1) # print var1 } vartest(8) # Inside our function var1 is now our argument and takes its value var1 Be very careful when creating variables inside a conditionnal statement as the variable may never have been created and cause (sometimes unperceptible) errors. It is good practice to define variables outside the conditions and then modify their values to avoid any problem a &lt;- 3 if (a &gt; 5) { b &lt;- 2 } a + b If you had b already assigned in your environment, with a different value, you could have had a *bigger* problem! No error would have been shown and a + b would have meant another thing! 6.6.1 Good programming practices Why should I care about programming practices? - To make your life easier; - To achieve greater readability and makes sharing and reusing your code a lot less painful; - To reduce the time you will spend to understand your code. 6.6.2 Pay attention to the next tips! ** Keep a clean and nice code ** Proper indentation and spacing is the first step to get an easy to read code: Use spaces between and after you operators Use consistently the same assignation operator. &lt;- is often preferred. = is OK, but do not switch all the time between the two Use brackets when using flow control statements: Inside brackets, indent by *at least* two spaces; Put closing brackets on a separate line, except when preceding an `else` statement. Define each variable on its own line. This code is not spaced, and therefore hard to read. All brackets are badly aligned, and it looks \"messy\". a&lt;-4;b=3 if(a&lt;b){ if(a==0)print(&quot;a zero&quot;)}else{ if(b==0){print(&quot;b zero&quot;)}else print(b) This looks more organized, no? a &lt;- 4 b &lt;- 3 if (a &lt; b) { if (a == 0) { print(&quot;a zero&quot;) } } else { if (b == 0) { print(&quot;b zero&quot;) } else { print(b) } } 6.6.3 Use functions to simplify your code Write your own function: 1.- When portion of the code is repeated more than twice in your script; 2.- If only a part of the code changes and includes options for different arguments. This would also reduce the number of potential errors done by copy-pasting, and the time needed to correct them. Let’s modify the example from Challenge #3 and suppose that all $CO_2$ uptake from Mississipi plants was overestimated by 20 and Quebec underestimated by 50. We could write this: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Mississippi&quot;) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$conc[i] &lt;- CO2$conc[i] + 50 } } Or this: recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$conc[i] &lt;- CO2$conc[i] + bias } } return(CO2) } newCO2 &lt;- recalibrate(CO2, &quot;Mississipi&quot;, -20) newCO2 &lt;- recalibrate(newCO2, &quot;Quebec&quot;, +50) 6.6.4 Use meaningful names for functions Same function as before, but with vague names rc &lt;- function(c, t, b) { for (i in 1:nrow(c)) { if (c$Type[i] == t) { c$uptake[i] &lt;- c$uptake[i] + b } } return(c) } 6.6.5 Use comments Add comment to describe what your code does, how to use its arguments or a detailed step-by-step description the function. # Recalibrates the CO2 dataset by modifying the CO2 uptake # concentration by a fixed amount depending on the region # of sampling # Arguments CO2: the CO2 dataset type: the type # (&#39;Mississippi&#39; or &#39;Quebec&#39;) that need to be recalibrated. # bias: the amount to add or remove to the concentration # uptake recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$uptake[i] &lt;- CO2$uptake[i] + bias } } return(CO2) } 6.6.6 Thank you for attending this workshop! "],["references.html", "References", " References "]]
