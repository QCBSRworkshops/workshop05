[["index.html", "Workshop 5: Programming in R QCBS R Workshop Series Preface 0.1 Code of conduct 0.2 Contributors 0.3 Contributing 0.4 Learning objectives", " Workshop 5: Programming in R QCBS R Workshop Series Developed and maintained by the contributors of the QCBS R Workshop Series1 2021-09-22 01:41:07 Preface The QCBS R Workshop Series is a series of 10 workshops that walks participants through the steps required to use R for a wide array of statistical analyses relevant to research in biology and ecology. These open-access workshops were created by members of the QCBS both for members of the QCBS and the larger community. The content of this workshop has been peer-reviewed by several QCBS members. If you would like to suggest modifications, please contact the current series coordinators, listed on the main Github page. 0.1 Code of conduct The QCBS R Workshop Series and the QCBS R Symposium are venues dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. Participants, presenters and organizers of the workshop series and other related activities accept this Code of Conduct when being present at any workshop-related activities. We do not tolerate behaviour that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. 0.1.1 Expected behaviour All participants are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members 0.1.2 Unacceptable behaviour Examples of unacceptable behaviour by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the - basis of membership of any specific group; causing someone to fear for their safety, such as through stalking or intimidation; violent threats or language directed against another person; the display of sexual or violent images; unwelcome sexual attention; nonconsensual or unwelcome physical contact; insults or put-downs; sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes; incitement to violence, suicide, or self-harm; continuing to initiate interaction (including photography or recording) with - someone after being asked to stop; publication of private communication without consent. 0.2 Contributors Since 2014, several QCBS members contributed to consistently and collaboratively develop and update this workshop, as part of the Learning and Development Award from the Québec Centre for Biodiversity Science. They were: Contributed with changes to the presentation: Pedro Henrique Pereira Braga, Parnian Pourtaherian, Kate Sheridan, Katherine Hébert, Gabriel Muñoz, Marie-Hélène Brice Contributed with changes to the written material: Pedro Henrique Pereira Braga, Gabriel Muñoz Contributed by reporting issues and suggesting modifications: 0.3 Contributing Under construction. 0.4 Learning objectives This workshop focuses on basic programming in R. You will learn how to use control flow (for loops, if, while, repeat, and apply() family functions) methods to prevent code repetition, facilitate organization and run simulations. You will also learn to write your own functions, and tips to program efficiently. Recognizing control flow; Getting comfortable with testing conditions and performing iterations; Developing your first functions in R; Discovering how to accelerate your code; Demonstrating useful R packages for biologists. The QCBS R Workshop Series is part of the Québec Centre for Biodiversity Science, and is maintained by the series coordinators and graduent student, postdoctoral, and research professional members. The contributors for this workshop can be accessed here.↩︎ "],["preparing-for-the-workshop.html", "Chapter 1 Preparing for the workshop", " Chapter 1 Preparing for the workshop To prepare for this workshop, you must download and install the earliest RStudio and R versions. All workshop materials are found within the Github repository for this workshop. This includes an R script, which contains all code chunks shown in this book. To reproduce the diagrams included in this workshop, you will need the DiagrammeR package. You can install and load it with the following command: install.packages(&quot;DiagrammeR&quot;) library(DiagrammeR) Accessing the workshop material "],["introduction-to-control-flow.html", "Chapter 2 Introduction to Control Flow", " Chapter 2 Introduction to Control Flow The basis of computer programming in any language begins with control flow. Control flow (or flow of control) is the order function calls, instructions, and statements are executed or evaluate when any program is running. Imagine that you would like to run an operation several times, until a condition is met. One option, is to rewrite the same code, while changing part of the syntax, that number of times you wish. Alternatively, we could write our code using control flow, and iterate through the same operation that will evaluate and stop until a certain condition is met. This last option usually implies in a much shorter, clearer and less complex form of writing code. It is advantageous, for any programmer, to think in terms of in terms of control flow, and therefore have structured programs, because: The complexity and time of the task at hand is greatly decreased; A logical structure also means that the code has increased clarity; It also facilitates collaboration, and therefore increases productivity. 2.0.1 Building blocks of control flow There are many building blocks of control flow programming: Sequencing, which executes or evaluates something sequentially; Selection, which performs operations ìf or unless certain conditions are met; Iteration, which repeats an operation while, until or for a determined number of times; Procedural abstraction, which involves a subroutine, nested call; Recursion Concurrency, which does several operations at the same time; Exception handling and speculation Non-determinism, which does an operation "],["using-flowcharts.html", "Chapter 3 Using flowcharts", " Chapter 3 Using flowcharts Control-flow diagrams can be used to plan and represent the structure of programs. The main elements program-flowcharts are: A processing step, represented by the rectangular box; A decision step, usually denoted by a diamond; The start and end steps, denoted by rounded-edge rectangles; Arrows indicating the direction and each step; Labels naming elements of the flowchart. "],["decision-making.html", "Chapter 4 Decision making", " Chapter 4 Decision making It is not rare that we wish to conditionally perform operations - or in other words, to perform different operations depending on the outcome of a test of desired conditions. We can use if() {}, if() {} else {} and ifelse() to help us with this selection process. "],["if-statement.html", "Chapter 5 if statement", " Chapter 5 if statement In the example below, the expression is only executed if the condition that is being tested is TRUE. if (condition) { expression } Note that when the condition is FALSE, nothing happens and the program carries on to the next step. "],["if-else-statement.html", "Chapter 6 if else statement", " Chapter 6 if else statement The if statement only performs an operation if a condition is met. However, one may not only be interested in specifying the expression that must be done when the required condition is TRUE, but also the expression that must be performed when the condition is FALSE. To achieve this, we can use the if() {} else {} statement and ifelse() function. if(condition) { expression 1 } else { expression 2 } ifelse(condition, expression 1, expression 2 ) "],["multiple-condition-decisions.html", "Chapter 7 Multiple condition decisions", " Chapter 7 Multiple condition decisions While simple if and if else operations tests single conditions, we can make more complex operations, which tests multiple conditions. With the ifelse() function, we can test a test a vector of conditions and/or apply functions only under certain conditions. See the examples below: a &lt;- 1:10 ifelse(test = a &gt; 5, yes = &quot;yes&quot;, no = &quot;no&quot;) ## [1] &quot;no&quot; &quot;no&quot; &quot;no&quot; &quot;no&quot; ## [5] &quot;no&quot; &quot;yes&quot; &quot;yes&quot; &quot;yes&quot; ## [9] &quot;yes&quot; &quot;yes&quot; a &lt;- (-4):5 sqrt(ifelse(test = a &gt;= 0, yes = a, no = NA)) ## [1] NA NA ## [3] NA NA ## [5] 0.000000 1.000000 ## [7] 1.414214 1.732051 ## [9] 2.000000 2.236068 While the if() and if() else statements leave you with exactly two options, nested if() else statement allows you consider more alternatives. if (test_expression1) { statement1 } else if (test_expression2) { statement2 } else if (test_expression3) { statement3 } else { statement4 } "],["caution-with-parsing-statements.html", "Chapter 8 Caution with parsing statements", " Chapter 8 Caution with parsing statements What do you think will happen if we try the code below? if(2+2) == 4 print(&quot;Arithmetic works.&quot;) else print(&quot;Houston, we have a problem.&quot;) ## Error: &lt;text&gt;:1:9: unexpected &#39;==&#39; ## 1: if(2+2) == ## ^ This does not work because R evaluates the first line and does not know that you are going to use an else statement Use curly brackets { } so that R knows to expect more input. Try: if (2 + 2 == 4) { print(&quot;Arithmetic works.&quot;) } else { print(&quot;Houston, we have a problem.&quot;) } ## [1] &quot;Arithmetic works.&quot; "],["challenge-1.html", "Chapter 9 Challenge 1", " Chapter 9 Challenge 1 Welcome to our first challenge! To complete it, you will use the code block below, and you must: Use an if() statement to print “meow” if Paws is a “cat”. Use an if() else statement to print \"woof\" if you supply an object that is a \"dog\" and \"meow\" if it is not. Try it out with Paws and Scruffy. Use the ifelse() function to display \"woof\" for animals that are dogs and \"meow\" for animals that are cats. Paws &lt;- &quot;cat&quot; Scruffy &lt;- &quot;dog&quot; Sassy &lt;- &quot;cat&quot; animals &lt;- c(Paws, Scruffy, Sassy) Here is a cheatsheet with logical operators that can help you completing this exercise: Command Meaning == equal to != not equal to &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than or equal to x&amp;y x AND y x|y x OR y isTRUE(x) test if x is true Solution for Challenge 1 Use an if() statement to print “meow” if Paws is a “cat”. if (Paws == &quot;cat&quot;) { print(&quot;meow&quot;) } ## [1] &quot;meow&quot; 2. Use an if() else statement to print “woof” if you supply an object that is a “dog” and “meow” if it is not. Try it out with Paws and Scruffy. x = Paws # x = Scruffy if (x == &quot;cat&quot;) { print(&quot;meow&quot;) } else { print(&quot;woof&quot;) } ## [1] &quot;meow&quot; 3. Use the ifelse() function to display “woof” for animals that are dogs and “meow” for animals that are cats. animals &lt;- c(Paws, Scruffy, Sassy) ifelse(animals == &quot;dog&quot;, &quot;woof&quot;, &quot;meow&quot;) ## [1] &quot;meow&quot; &quot;woof&quot; &quot;meow&quot; or for (val in 1:3) { if (animals[val] == &quot;cat&quot;) { print(&quot;meow&quot;) } else if (animals[val] == &quot;dog&quot;) { print(&quot;woof&quot;) } else print(&quot;what?&quot;) } ## [1] &quot;meow&quot; ## [1] &quot;woof&quot; ## [1] &quot;meow&quot; "],["iteration.html", "Chapter 10 Iteration", " Chapter 10 Iteration Every time some operations have to be repeated, a loop may come in handy. Loops are good for: Doing something for every element of an object; Doing something until the processed data runs out; Doing something for every file in a folder; Doing something that can fail, until it succeeds; Iterating a calculation until it reaches convergence. Here, we will learn the following types of iteration statements: for() {} while() {} repeat {} We will also dive into the apply() family functions, which are interesting function-based alternatives to for() {} loops. We will finally learn about two special statements that allow us to control iterations: break next "],["for-loops.html", "Chapter 11 for loops", " Chapter 11 for loops A for() loop works in the following way: for(i in sequence) { expression } The letter i can be replaced with any variable name, sequence can be elements or the position of these elements, and expression can be anything. Try the examples below: for (a in c(&quot;Hello&quot;, &quot;R&quot;, &quot;Programmers&quot;)) { print(a) } for (z in 1:4) { a &lt;- rnorm(n = 1, mean = 5 * z, sd = 2) print(a) } Output ## [1] &quot;Hello&quot; ## [1] &quot;R&quot; ## [1] &quot;Programmers&quot; ## [1] 6.217668 ## [1] 7.136476 ## [1] 15.53246 ## [1] 16.85912 "],["examples-using-for.html", "Chapter 12 Examples using for 12.1 Simple for loop 12.2 for loops on different classes 12.3 for and if together 12.4 for with a real dataset", " Chapter 12 Examples using for 12.1 Simple for loop In this next example, every instance of m is being replaced by each number between 1 and 7, until it reaches the last element of the sequence: y &lt;- 2 for (m in 1:6) { print(y * m) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 ## [1] 12 12.2 for loops on different classes As expected, you can use for() loops in different object types and classes, such as a list. Let us take the example below, where we are creating the elements object list. (elements &lt;- list(a = 1:3, b = 4:10, c = 7:-1)) ## $a ## [1] 1 2 3 ## ## $b ## [1] 4 5 6 7 8 9 10 ## ## $c ## [1] 7 6 5 4 3 2 1 0 -1 Now, let us print the double of every element of the list: for (element in elements) { print(element * 2) } ## [1] 2 4 6 ## [1] 8 10 12 14 16 18 20 ## [1] 14 12 10 8 6 4 2 0 -2 12.3 for and if together Let us perform operations for even elements within x using the modulo operator (%%): x &lt;- c(2, 5, 3, 9, 6) count &lt;- 0 for (val in x) { if (val%%2 == 0) { count &lt;- count + 1 } } print(count) ## [1] 2 The above example can be represented within the following flowchart: 12.4 for with a real dataset for() loops are often used to loop over a dataset. We will use loops to perform functions on the CO2 dataset which is built in R. To load and see the first 6 rows of the CO2 dataset, execute the following code: data(CO2) # This loads the built in dataset head(CO2) ## Plant Type Treatment ## 1 Qn1 Quebec nonchilled ## 2 Qn1 Quebec nonchilled ## 3 Qn1 Quebec nonchilled ## 4 Qn1 Quebec nonchilled ## 5 Qn1 Quebec nonchilled ## 6 Qn1 Quebec nonchilled ## conc uptake ## 1 95 16.0 ## 2 175 30.4 ## 3 250 34.8 ## 4 350 37.2 ## 5 500 35.3 ## 6 675 39.2 Now, to recursively print the CO2 concentration, let us do this: for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset print(CO2$conc[i]) # print the CO2 concentration } Here are the first 40 outputs: ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 Now, let us obtain the CO2 concentration only for the sites that were sampled in Québec (Canada): for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } Here they are: ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 Tip 1. To loop over the number of rows of a data frame, we can use the function nrow(): for (i in 1:nrow(CO2)) { # for each row in the CO2 dataset print(CO2$conc[i]) # print the CO2 concentration } Tip 2. To perform operations on the elements of one column, we can directly iterate over it. for (p in CO2$conc) { # for each element of the column &#39;conc&#39; of the CO2 df print(p) # print the p-th element } Tip 3. The expression within the loop can be almost anything and is usually a compound statement containing many commands. for (i in 4:5) { # for i in 4 to 5 print(colnames(CO2)[i]) print(mean(CO2[, i])) # print the mean of that column from the CO2 dataset } "],["for-loops-within-for-loops.html", "Chapter 13 for loops within for loops", " Chapter 13 for loops within for loops In some cases, you may want to use nested loops to accomplish a task. When using nested loops, it is important to use different variables for each one of your loops. In the example below, we used a nested for framework which printed the product of i and n, where n was part of the nested for and was a sequence from 1 to 3, and then i, which was also a sequence from 1 to 3, was part of the outer loop. for (i in 1:3) { for (n in 1:3) { print(i * n) } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 3 ## [1] 6 ## [1] 9 Specifically, the operation above beings as follows: i takes the first value from 1 to 3, i.e. \\(i = 1\\); n takes the first value from 1 to 3, i.e. \\(n = 1\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 1 \\times 1 = 1\\); n takes the second value from 1 to 3, i.e. \\(n = 2\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 1 \\times 2 = 2\\); n takes the third value from 1 to 3, i.e. \\(n = 3\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 1 \\times 3 = 3\\); i takes the second value from 1 to 3, i.e. \\(i = 2\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 2 \\times 1 = 2\\); n takes the second value from 1 to 3, i.e. \\(n = 2\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 2 \\times 2 = 4\\); n takes the third value from 1 to 3, i.e. \\(n = 3\\); The product of the current value of i and n is computed and printed, i.e. \\(i \\times n = 2 \\times 3 = 6\\); Would you be able to follow up with the rest of the iteration? "],["the-apply-family.html", "Chapter 14 The apply() family 14.1 apply() 14.2 lapply() 14.3 sapply() 14.4 mapply() 14.5 tapply()", " Chapter 14 The apply() family R disposes of the apply() function family, which consists of iterative functions that aim at minimizing your need to explicitly create loops. 14.1 apply() Let us consider that we have a height matrix containing the height (in metres) that was taken from five individuals (in rows) at four different times (as columns). (height &lt;- matrix(runif(20, 1.5, 2), nrow = 5, ncol = 4)) ## [,1] [,2] ## [1,] 1.700784 1.958925 ## [2,] 1.713667 1.504426 ## [3,] 1.973446 1.850892 ## [4,] 1.622950 1.895789 ## [5,] 1.526203 1.616419 ## [,3] [,4] ## [1,] 1.605343 1.709269 ## [2,] 1.977772 1.606771 ## [3,] 1.708897 1.515716 ## [4,] 1.936138 1.856771 ## [5,] 1.877783 1.603157 We would like to obtain the average height at each time step. One option is to use a for() {} loop to iterate from column 1 to 4, use the function mean() to calculate the average of the values, and sequentially store the output value in a vector. Alternatively, we can use the apply() function to set it to apply the mean() function to every column of the height matrix. See the example below: apply(X = height, MARGIN = 2, FUN = mean) ## [1] 1.707410 1.765290 1.821187 ## [4] 1.658337 The apply() function begins with three arguments main arguments: X, which will take a matrix or a data frame; FUN, which can be any function that will be applied to the MARGINs of X; and MARGIN which will take 1 for row-wise computations, or 2 for column-wise computations. 14.2 lapply() lapply() applies a function to every element of a list. The output returned is also list (explaining the “l” in lapply) and has the same number of elements as the object passed to it. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list lapply(X = SimulatedData, FUN = mean) ## $SimpleSequence ## [1] 2.5 ## ## $Norm10 ## [1] 0.7331022 ## ## $Norm20 ## [1] 0.9760843 ## ## $Norm100 ## [1] 4.9592 lapply() operations done in objects different from a list will be coerced to a list via base::as.list(). 14.3 sapply() sapply() is a ‘wrapper’ function for lapply(), but returns a simplified output as a vector, instead of a list. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list sapply(SimulatedData, mean) ## SimpleSequence Norm10 ## 2.5000000 -0.3571188 ## Norm20 Norm100 ## 1.2642004 4.9668461 14.4 mapply() mapply() works as a multivariate version of sapply(). It will apply a given function to the first element of each argument first, followed by the second element, and so on. For example: lilySeeds &lt;- c(80, 65, 89, 23, 21) poppySeeds &lt;- c(20, 35, 11, 77, 79) # Output mapply(sum, lilySeeds, poppySeeds) ## [1] 100 100 100 100 100 14.5 tapply() tapply() is used to apply a function over subsets of a vector. It is primarily used when the dataset contains dataset contains different groups (i.e. levels/factors) and we want to apply a function to each of these groups. head(mtcars) ## mpg cyl ## Mazda RX4 21.0 6 ## Mazda RX4 Wag 21.0 6 ## Datsun 710 22.8 4 ## Hornet 4 Drive 21.4 6 ## Hornet Sportabout 18.7 8 ## Valiant 18.1 6 ## disp hp ## Mazda RX4 160 110 ## Mazda RX4 Wag 160 110 ## Datsun 710 108 93 ## Hornet 4 Drive 258 110 ## Hornet Sportabout 360 175 ## Valiant 225 105 ## drat wt ## Mazda RX4 3.90 2.620 ## Mazda RX4 Wag 3.90 2.875 ## Datsun 710 3.85 2.320 ## Hornet 4 Drive 3.08 3.215 ## Hornet Sportabout 3.15 3.440 ## Valiant 2.76 3.460 ## qsec vs am ## Mazda RX4 16.46 0 1 ## Mazda RX4 Wag 17.02 0 1 ## Datsun 710 18.61 1 1 ## Hornet 4 Drive 19.44 1 0 ## Hornet Sportabout 17.02 0 0 ## Valiant 20.22 1 0 ## gear carb ## Mazda RX4 4 4 ## Mazda RX4 Wag 4 4 ## Datsun 710 4 1 ## Hornet 4 Drive 3 1 ## Hornet Sportabout 3 2 ## Valiant 3 1 # get the mean hp by cylinder groups tapply(mtcars$hp, mtcars$cyl, FUN = mean) ## 4 6 8 ## 82.63636 122.28571 209.21429 "],["challenge-2.html", "Chapter 15 Challenge 2", " Chapter 15 Challenge 2 You have realized that your tool for measuring uptake was not calibrated properly at Quebec sites and all measurements are 2 units higher than they should be. Use a loop to correct these measurements for all Québec sites. Use a vectorisation-based method to calculate the mean \\(CO_2\\) uptake in both areas. For this, you must load the \\(\\text{CO}_{2}\\) dataset using data(CO2), and then use the object CO2. Solution for Challenge 2 1.-Using for and if to correct the measurements: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$uptake[i] &lt;- CO2$uptake[i] - 2 } } 2.- Using tapply() to calculate the mean for each group: tapply(CO2$uptake, CO2$Type, mean) ## Quebec Mississippi ## 31.54286 20.88333 "],["modifying-iterations-break-next-and-while.html", "Chapter 16 Modifying iterations: break, next and while 16.1 next 16.2 break", " Chapter 16 Modifying iterations: break, next and while In R, a standard looping sequence may be modified with the break, next and while statements. 16.1 next next allows us to skip an iteration if a certain condition is met. It is used inside the loop and is usually joined by the if statement, as shown below: for (val in x) { if (condition) { next } statement } 16.2 break The break statement is used inside a loop to terminate and exit the iteration when a certain condition is met. for (val in x) { if (condition) { break } statement } "],["repeat-loops.html", "Chapter 17 repeat loops", " Chapter 17 repeat loops A repeat loop performs an operation until it is deliberately stopped. One may either use Escape to halt it, or more adequately, use break. repeat { expression if { condition } break } If you attempt to run the following chunk of code using repeat, it will display the result until you press Escape. repeat { print(&quot;Press &#39;Esc&#39; to stop me!&quot;) } [1] &quot;Press &#39;Esc&#39; to stop me!&quot; [1] &quot;Press &#39;Esc&#39; to stop me!&quot; ... ... [1] &quot;Press &#39;Esc&#39; to stop me!&quot; "],["while-loops.html", "Chapter 18 while loops", " Chapter 18 while loops Within the while loop, an expression happens while a condition is met. while (condition) { expression } "],["examples-with-modifying-statements.html", "Chapter 19 Examples with modifying statements", " Chapter 19 Examples with modifying statements We can print \\(\\text{CO}_{2}\\) concentrations for chilled treatments and keep count of how many replications using next. count &lt;- 0 for (i in 1:nrow(CO2)) { if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # Skip to next iteration if treatment is nonchilled count &lt;- count + 1 # print(CO2$conc[i]) # You can turn this on if you want # to } print(count) # The count and print command were performed 42 times. ## [1] 42 sum(CO2$Treatment == &quot;chilled&quot;) ## [1] 42 Alternatively, we could have written the example above using repeat and break: count &lt;- 0 i &lt;- 0 repeat { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) if (i == nrow(CO2)) break # stop looping } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 Finally, one could have also done this using a while loop: i &lt;- 0 count &lt;- 0 while (i &lt; nrow(CO2)) { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 "],["challenge-3.html", "Chapter 20 Challenge 3", " Chapter 20 Challenge 3 You have realized that another of your tools was not working properly! At Mississippi sites, concentrations less than 300 were measured correctly, but concentrations equal or higher than 300 were overestimated by 20 units! Your mission is to use a loop to correct these measurements for all Mississippi sites. Tip. Make sure you reload the \\(\\text{CO}_{2}\\) data so that we are working with the raw data for the rest of the exercise: data(CO2) Solution for Challenge 3 Challenge 3: Answer for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot;) { if (CO2$conc[i] &lt; 300) next CO2$conc[i] &lt;- CO2$conc[i] - 20 } } We could also have written it in this way, which is more concise and clearer. for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot; &amp;&amp; CO2$conc[i] &gt;= 300) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } "],["edit-a-plot-using-for-and-if.html", "Chapter 21 Edit a plot using for and if", " Chapter 21 Edit a plot using for and if Let us plot uptake versus concentration with points of different colors according to their type (Québec or Mississippi) and treatment (chilled or nonchilled). plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;) } if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;orange&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;green&quot;) } } "],["challenge-4.html", "Chapter 22 Challenge 4", " Chapter 22 Challenge 4 Generate a plot of comparing the CO2 concentration versus uptake where each plant is shown using a different point. Bonus points for doing this challenge using nested loops! Solution for Challenge 4 Challenge 4: Answer plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 Concentration&quot;, ylab = &quot;CO2 Uptake&quot;) plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } "],["why-write-functions.html", "Chapter 23 Why write functions? 23.1 What is a function? 23.2 Syntax of a function: function() 23.3 Arguments of a function() 23.4 Default argument values in a function 23.5 The ellipsis argument: ... 23.6 The ellipsis argument: ... 23.7 Return values 23.8 Return values 23.9 Accessibility of variables 23.10 Accessibility of variables 23.11 Accessibility of variables 23.12 Additional good programming practices 23.13 Why should I care about programming practices? 23.14 Keep a clean and nice code 23.15 Keep a clean and nice code 23.16 Keep a clean and nice code 23.17 Use functions to simplify your code 23.18 Use functions to simplify your code 23.19 Use meaningful names for functions 23.20 Use comments: # 23.21 Group exercise: Solution", " Chapter 23 Why write functions? Much of the heavy lifting in R is done by functions! Functions are useful for: Performing a task repeatedly, but configurable; Making code more readable; Making code easier to modify and maintain; Sharing code between different analyses; Sharing code with other people; Modifying R’s built-in functionality. 23.1 What is a function? 23.2 Syntax of a function: function() function_name &lt;- function(argument1, argument2, ...) { body # What we want the function to do return(values) # Optional } function_name is the name of the function, and will be stored in the R environemnt as an object with this name; arguments take the defined values that can be used within the function; body contains the statements that define what the function does; output contains the returned value from the function. If return() is absent, then the last expression is returned. 23.3 Arguments of a function() function_name &lt;- function(argument1, argument2, ...) { body # What we want the function to do return(values) # Optional } Arguments are the input values of your function and will have the information your function needs to be able to perform correctly. A function can have between zero and an infinity of arguments. See the following example: operations &lt;- function(number1, number2, number3) { result &lt;- (number1 + number2) * number3 print(result) } operations(1, 2, 3) ## [1] 9 Challenge 4 Using what you learned previously on flow control, create a function print_animal() that takes an animal as argument and gives the following results: Scruffy &lt;- &quot;dog&quot; Paws &lt;- &quot;cat&quot; print_animal(Scruffy) ## [1] &quot;woof&quot; print_animal(Paws) ## [1] &quot;meow&quot; Challenge 4: Solution Using what you learned previously on flow control, create a function print_animal() that takes an animal as argument and gives the following results: Scruffy &lt;- &quot;dog&quot; Paws &lt;- &quot;cat&quot; print_animal(Scruffy) ## [1] &quot;woof&quot; print_animal(Paws) ## [1] &quot;meow&quot; print_animal &lt;- function(animal) { if (animal == &quot;dog&quot;) { print(&quot;woof&quot;) } else if (animal == &quot;cat&quot;) { print(&quot;meow&quot;) } } 23.4 Default argument values in a function Arguments can be provided with a default value, or even be optional. Default values are useful when using a function with the same settings. The flexibility to depart from default values is still there, if needed. operations &lt;- function(number1, number2, number3 = 3) { result &lt;- (number1 + number2) * number3 print(result) } operations(number1 = 1, number2 = 2, number3 = 3) ## [1] 9 # is equivalent to operations(1, 2) ## [1] 9 operations(1, 2, 2) # we can still change the value of number3 if needed ## [1] 6 23.5 The ellipsis argument: ... The special argument ... allows you to pass arguments from other undefined functions, i.e. allowing for an indefinite number of arguments to be inputed. paste_anything_fun &lt;- function(...) { arguments &lt;- list(...) paste0(arguments) } paste_anything_fun(&quot;I&quot;, &quot;want&quot;, &quot;a break!&quot;) ## [1] &quot;I&quot; &quot;want&quot; ## [3] &quot;a break!&quot; percentages &lt;- function(x, mult = 100, ...) { percent &lt;- round(x * mult, ...) paste(percent, &quot;%&quot;, sep = &quot;&quot;) } percentages(c(0.543, 0.534, 0.466)) ## [1] &quot;54%&quot; &quot;53%&quot; &quot;47%&quot; # ?round percentages(c(0.543, 0.534, 0.466), digits = 2) ## [1] &quot;54.3%&quot; &quot;53.4%&quot; &quot;46.6%&quot; 23.6 The ellipsis argument: ... The special argument ... allows you to pass on arguments to another function used inside your function. Here we use ... to pass on arguments to plot() and points(). plot.CO2 &lt;- function(CO2, ...) { plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, ...) for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;, type = &quot;p&quot;, ...) } else if (CO2$Type[i] == &quot;Mississippi&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;, type = &quot;p&quot;, ...) } } } plot.CO2(CO2, cex.lab = 1.2, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) plot.CO2(CO2, cex.lab = 1.2, pch = 20, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) 23.7 Return values The last expression evaluated in a function becomes the return value: myfun &lt;- function(x) { if (x &lt; 10) { 0 } else { 10 } } myfun(5) ## [1] 0 myfun(15) ## [1] 10 function() itself returns the last evaluated value even without including return() 23.8 Return values .small[ It can be useful to explicitly return() if the routine should end early, jump out of the function and return a value. simplefun1 &lt;- function(x) { if (x &lt; 0) return(x) } Functions can return only a single object (and text). But this is not a limitation because you can return a list containing any number of objects. simplefun2 &lt;- function(x, y) { z &lt;- x + y return(list(result = z, x = x, y = y)) } simplefun2(1, 2) ## $result ## [1] 3 ## ## $x ## [1] 1 ## ## $y ## [1] 2 Challenge 5 Using what you have just learned on functions and control flow, create a function named bigsum that takes two arguments a and b and: Returns \\(0\\) if the sum of a and b is strictly less than \\(50\\); Else, returns the sum of a and b. Challenge 5: Solution Using what you have just learned on functions and control flow, create a function named bigsum that takes two arguments a and b and: Returns 0 if the sum of a and b is strictly less than 50; Else, returns the sum of a and b. Answer 1 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { return(0) } else { return(result) } } Answer 2 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { 0 } else { result } } 23.9 Accessibility of variables It is essential to always keep in mind where your variables are, and whether they are defined and accessible: Variables defined .alert[inside] a function are not accessible outside from it! Variables defined .alert[outside] a function are accessible inside, and are not modified, even if they have the same name. out_val &lt;- 3 vartest &lt;- function() { in_val &lt;- 4 print(in_val) print(out_val) } vartest() ## [1] 4 ## [1] 3 in_val ## Error in eval(expr, envir, enclos): object &#39;in_val&#39; not found out_val ## [1] 3 out_val_2 &lt;- 3 vartest &lt;- function(out_val_2) { print(out_val_2) } vartest(8) ## [1] 8 out_val_2 ## [1] 3 What happens in the function club, stays in the function club. 23.10 Accessibility of variables var1 &lt;- 3 vartest &lt;- function() { a &lt;- 4 # &#39;a&#39; is defined inside print(a) # print &#39;a&#39; print(var1) # print var1 } a # we cannot print &#39;a&#39; as it exists only inside the function ## [1] 16.85912 vartest() # calling vartest() will print a and var1 ## [1] 4 ## [1] 3 rm(var1) # remove var1 vartest() # calling the function again does not work anymore ## [1] 4 ## Error in print(var1): object &#39;var1&#39; not found 23.11 Accessibility of variables Tip Be very careful when creating variables inside a conditional statement as the variable may never have been created and cause (sometimes imperceptible) errors. Tip It is good practice to define variables outside the conditions and then modify their values to avoid any problems. a &lt;- 3 if (a &gt; 5) { b &lt;- 2 } a + b # Error: object &#39;b&#39; not found If you had b already assigned in your environment, with a different value, you could have had a .alert[bigger] problem! No error would have been shown and a + b would have meant another thing!] class: inverse, center, middle 23.12 Additional good programming practices 23.13 Why should I care about programming practices? It makes your life easier; It helps you achieve greater readability and makes sharing and reusing your code a lot less painful; It helps reduce the time you will spend remembering and understanding your own code. Pay attention to the next tips! 23.14 Keep a clean and nice code Proper indentation and spacing is the first step to get an easy to read code: Use spaces between and after your operators; x&gt;=1&amp;x&lt;=10 is more difficult to read then x &gt;= 1 &amp; x &lt;= 10 Use consistently the same assignation operator; &lt;- is often preferred. = is sometimes OK, but do not switch all the time between the two. Use brackets and returns when using flow control statements; Inside brackets, indent by at least two returns; Put closing brackets on a separate line, except when preceding an else statement. Define each variable on its own line; Use Cmd + I or Ctrl + I in RStudio to indent the highlighted code automatically; if ((a[x, y] &gt; 1) &amp; (a[x, y] &lt; 2)) { print(&quot;Between 1 and 2&quot;) } if ((a[x, y] &gt; 1) &amp; (a[x, y] &lt; 2)) { print(&quot;Between 1 and 2&quot;) } 23.15 Keep a clean and nice code On the left, code is not spaced, nor indented. All brackets are in the same line, and it looks “messy”. a &lt;- 4 b = 3 if (a &lt; b) { if (a == 0) print(&quot;a zero&quot;) } else { if (b == 0) { print(&quot;b zero&quot;) } else print(b) } ## [1] 3 23.16 Keep a clean and nice code On the left, code is not spaced, nor indented. All brackets are in the same line, and it looks “messy”. On the right, it looks more organized, no? a &lt;- 4 b = 3 if (a &lt; b) { if (a == 0) print(&quot;a zero&quot;) } else { if (b == 0) { print(&quot;b zero&quot;) } else print(b) } ## [1] 3 a &lt;- 4 b &lt;- 3 if (a &lt; b) { if (a == 0) { print(&quot;a zero&quot;) } } else { if (b == 0) { print(&quot;b zero&quot;) } else { print(b) } } ## [1] 3 23.17 Use functions to simplify your code Write your own function: 1. When portion of the code is repeated more than a few times in your script; 2. If only a part of the code changes and includes options for different arguments. This would also reduce the number of potential errors done by copy-pasting, and the time needed to correct them. 23.18 Use functions to simplify your code Let’s modify the example from Challenge 3 and suppose that all \\(CO_2\\) uptake from Mississipi plants was overestimated by 20 and Quebec underestimated by 50. We could write this: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Mississippi&quot;) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$conc[i] &lt;- CO2$conc[i] + 50 } } Or this: recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$conc[i] &lt;- CO2$conc[i] + bias } } return(CO2) } newCO2 &lt;- recalibrate(CO2 = CO2, type = &quot;Mississipi&quot;, bias = -20) newCO2 &lt;- recalibrate(newCO2, &quot;Quebec&quot;, +50) 23.19 Use meaningful names for functions Same function as before, but with vague names: rc &lt;- function(c, t, b) { for (i in 1:nrow(c)) { if (c$Type[i] == t) { c$uptake[i] &lt;- c$uptake[i] + b } } return(c) } What is c and rc? That being said: Whenever possible, avoid using names of existing R functions and variables to avoid confusion and conflits. 23.20 Use comments: # .alert[Final tip]. Add comments to describe what your code does, how to use its arguments or a detailed step-by-step description of the function. # Recalibrates the CO2 dataset by modifying the CO2 uptake # concentration by a fixed amount depending on the region # of sampling. Arguments CO2: the CO2 dataset type: the # type (&#39;Mississippi&#39; or &#39;Quebec&#39;) that need to be # recalibrated bias: the amount to add or remove to the # concentration uptake recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$uptake[i] &lt;- CO2$uptake[i] + bias } } return(CO2) } Challenge 6: Group exercise Using what you learned, write an if() statement that tests whether a numeric variable x is 0. If not, it assigns \\(cos(x)/x\\) to z, otherwise it assigns \\(1\\) to z. Create a function called my_function() that takes the variable x as argument and returns z. If we assign \\(45\\), \\(20\\), and \\(0\\) to x respectively, which of the following options would represent the results? 1. \\(0.054\\), \\(0.012\\), and \\(0\\); 2. \\(0.020\\), \\(0.054\\), and \\(1\\); 3. \\(0.012\\), \\(0.020\\), and \\(1\\). In addition to this, discuss with your group about a function that you would like to create (it can or it may not be related to your research). Be prepared to briefly describe it to us! ??? This exercise should take place in breakout rooms within 10 minutes. After rejoining the main room, a poll should be opened to participants. Once you obtain the response from participants, show them the correct answer and code. You may request that one of the participants explain their answer before showing the results. 23.21 Group exercise: Solution Correct answer is option 3 ( \\(0.12\\), \\(0.20\\), and \\(1\\) ). my_function &lt;- function(x) { if (x != 0) { z &lt;- cos(x)/x } else { z &lt;- 1 } return(z) } my_function(45) ## [1] 0.01167382 my_function(20) ## [1] 0.0204041 my_function(0) ## [1] 1 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
