[["index.html", "Workshop 5: Programming in R QCBS R Workshop Series Preface 0.1 Code of conduct 0.2 Contributors 0.3 Contributing 0.4 Objectifs d’apprentissage", " Workshop 5: Programming in R QCBS R Workshop Series Developed and maintained by the contributors of the QCBS R Workshop Series1 2021-12-02 02:04:35 Preface The QCBS R Workshop Series is a series of 10 workshops that walks participants through the steps required to use R for a wide array of statistical analyses relevant to research in biology and ecology. These open-access workshops were created by members of the QCBS both for members of the QCBS and the larger community. The content of this workshop has been peer-reviewed by several QCBS members. If you would like to suggest modifications, please contact the current series coordinators, listed on the main Github page. 0.1 Code of conduct The QCBS R Workshop Series and the QCBS R Symposium are venues dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. Participants, presenters and organizers of the workshop series and other related activities accept this Code of Conduct when being present at any workshop-related activities. We do not tolerate behaviour that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. 0.1.1 Expected behaviour All participants are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all workshop events and platforms: Use welcoming and inclusive language Be respectful of different viewpoints and experiences Gracefully accept constructive criticism Focus on what is best for the community Show courtesy and respect towards other community members 0.1.2 Unacceptable behaviour Examples of unacceptable behaviour by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the - basis of membership of any specific group; causing someone to fear for their safety, such as through stalking or intimidation; violent threats or language directed against another person; the display of sexual or violent images; unwelcome sexual attention; nonconsensual or unwelcome physical contact; insults or put-downs; sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes; incitement to violence, suicide, or self-harm; continuing to initiate interaction (including photography or recording) with - someone after being asked to stop; publication of private communication without consent. 0.2 Contributors Since 2014, several QCBS members contributed to consistently and collaboratively develop and update this workshop, as part of the Learning and Development Award from the Québec Centre for Biodiversity Science. They were: Contributed with changes to the presentation: Pedro Henrique Pereira Braga, Parnian Pourtaherian, Kate Sheridan, Katherine Hébert, Gabriel Muñoz, Marie-Hélène Brice Contributed with changes to the written material: Pedro Henrique Pereira Braga, Gabriel Muñoz Contributed by reporting issues and suggesting modifications: 0.3 Contributing Under construction. 0.4 Objectifs d’apprentissage Cet atelier se concentre sur la programmation de base en R. Vous apprendrez à utiliser les méthodes du flux de contrôle (boucles for, fonctions de la famille if, while, repeat et apply()) pour éviter la répétition du code, faciliter l’organisation et effectuer des simulations. Vous apprendrez également à écrire vos propres fonctions, et des astuces pour programmer efficacement. Reconnaître le flux de contrôle ; Se familiariser avec les tests de conditions et les itérations ; Développer vos premières fonctions en R ; Découvrir comment accélérer votre code ; Démonstration de paquets R utiles pour les biologistes. The QCBS R Workshop Series is part of the Québec Centre for Biodiversity Science, and is maintained by the series coordinators and graduent student, postdoctoral, and research professional members. The contributors for this workshop can be accessed here.↩︎ "],["préparation-de-latelier.html", "Chapter 1 Préparation de l’atelier", " Chapter 1 Préparation de l’atelier Pour vous préparer à cet atelier, vous devez télécharger et installer les premières versions de RStudio et de R. Tout le matériel de l’atelier se trouve dans le repositoire Github de cet atelier. Cela inclut un [script R] (https://qcbsrworkshops.github.io/fr/workshop05/workshop05-fr/workshop05-fr.R), qui contient tous les morceaux de code présentés dans ce livre. Pour reproduire les diagrammes inclus dans cet atelier, vous aurez besoin du paquetage DiagrammeR. Vous pouvez l’installer et le charger avec la commande suivante : install.packages(&quot;DiagrammeR&quot;) library(DiagrammeR) Accès au matériel de l’atelier "],["introduction-au-flux-de-contrôle.html", "Chapter 2 Introduction au flux de contrôle", " Chapter 2 Introduction au flux de contrôle La base de la programmation informatique, quel que soit le langage, commence par le flux de contrôle. Le flux de contrôle (ou control flow) est l’ordre dans lequel les appels de fonction, les instructions et les instructions sont exécutés ou évalués lorsqu’un programme est en cours d’exécution. Imaginez que vous souhaitiez exécuter une opération plusieurs fois, jusqu’à ce qu’une condition soit remplie. Une option, est de réécrire le même code, en changeant une partie de la syntaxe, le nombre de fois que vous le souhaitez. Une autre solution consiste à écrire notre code en utilisant le flux de contrôle, et à iterer à travers la même opération qui évaluera et s’arrêtera jusqu’à ce qu’une certaine condition soit remplie. Cette dernière option implique généralement une forme d’écriture du code beaucoup plus courte, plus claire et moins complexe. Il est avantageux, pour tout programmeur et programmeuse, de penser en termes de flux de contrôle, et donc d’avoir des programmes structurés, car : La complexité et le temps de la tâche à accomplir sont grandement diminués ; Une structure logique signifie également que le code a une clarté accrue ; Cela facilite également la collaboration, et augmente donc la productivité. 2.0.1 Building blocks of control flow Il existe de nombreux éléments constitutifs de la programmation par flux de contrôle : Séquencement, qui exécute ou évalue quelque chose de manière séquentielle ; Sélection, qui effectue des opérations if ou à moins que certaines conditions soient remplies ; L’itération**, qui répète une opération while, until ou for un nombre déterminé de fois ; L’abstraction procédurale, qui implique une sous-routine, un appel imbriqué ; Récursion ; Concurrence, qui effectue plusieurs opérations en même temps ; Traitement des exceptions et la spéculation ; Non-déterminisme. "],["utilisation-des-diagrammes-de-flux.html", "Chapter 3 Utilisation des diagrammes de flux", " Chapter 3 Utilisation des diagrammes de flux Les diagrammes de flux de contrôle peuvent être utilisés pour planifier et représenter la structure des programmes. Les principaux éléments des organigrammes de contrôle sont : Une étape de traitement, représentée par la boîte rectangulaire ; Une étape de décision, généralement désignée par un diamant ; Les étapes de début et de fin, représentées par des rectangles à bords arrondis ; Flèches indiquant la direction et chaque étape ; Des étiquettes désignant les éléments de l’organigramme. "],["prise-de-décision.html", "Chapter 4 Prise de décision", " Chapter 4 Prise de décision Il n’est pas rare que nous souhaitions effectuer des opérations conditionnellement - ou en d’autres termes, effectuer différentes opérations en fonction du résultat d’un test de conditions souhaitées. Nous pouvons utiliser if() {}, if() {} else {} et ifelse() pour nous aider dans ce processus de sélection. "],["règle-if.html", "Chapter 5 Règle if", " Chapter 5 Règle if Dans l’exemple ci-dessous, l’expression n’est exécutée que si la condition testée est “VRAIE” (ou TRUE). if (condition) { expression } Notez que lorsque la condition est FAUSSE (FALSE), rien ne se passe et le programme passe à l’étape suivante. "],["règle-if-else.html", "Chapter 6 Règle if else", " Chapter 6 Règle if else La directive if n’effectue une opération que si une condition est remplie. Cependant, on peut être intéressé non seulement par la spécification de l’expression qui doit être effectuée lorsque la condition requise est VRAIE (TRUE), mais aussi par l’expression qui doit être effectuée lorsque la condition est FAUSSE (FALSE). Pour ce faire, nous pouvons utiliser l’instruction if() {} else {} et la fonction ifelse(). if(condition) { expression 1 } else { expression 2 } ifelse(condition, expression 1, expression 2 ) "],["décisions-à-conditions-multiples.html", "Chapter 7 Décisions à conditions multiples", " Chapter 7 Décisions à conditions multiples Alors que les opérations simples if et if else testent des conditions uniques, nous pouvons faire des opérations plus complexes, qui testent des conditions multiples. Avec la fonction ifelse(), nous pouvons tester un vecteur de conditions et/ou appliquer des fonctions uniquement sous certaines conditions. Voir les exemples ci-dessous : a &lt;- 1:10 ifelse(test = a &gt; 5, yes = &quot;oui&quot;, no = &quot;non&quot;) ## [1] &quot;non&quot; &quot;non&quot; &quot;non&quot; &quot;non&quot; ## [5] &quot;non&quot; &quot;oui&quot; &quot;oui&quot; &quot;oui&quot; ## [9] &quot;oui&quot; &quot;oui&quot; a &lt;- (-4):5 sqrt(ifelse(test = a &gt;= 0, yes = a, no = NA)) ## [1] NA NA ## [3] NA NA ## [5] 0.000000 1.000000 ## [7] 1.414214 1.732051 ## [9] 2.000000 2.236068 Alors que les instructions if() {} et if() {} else {} vous laissent avec exactement deux options, l’instruction if() {} else if() {} imbriquée vous permet d’envisager plus d’alternatives. "],["décisions-à-conditions-multiples-1.html", "Chapter 8 Décisions à conditions multiples", " Chapter 8 Décisions à conditions multiples if (test_expression1) { statement1 } else if (test_expression2) { statement2 } else if (test_expression3) { statement3 } else { statement4 } "],["attention-à-lanalyse-des-déclarations.html", "Chapter 9 Attention à l’analyse des déclarations", " Chapter 9 Attention à l’analyse des déclarations A votre avis, que se passera-t-il si nous essayons le code ci-dessous ? if(2+2) == 4 print(&quot;L&#39;arithmétique fonctionne.&quot;) else print(&quot;Houston, we have a problem.&quot;) ## Error: &lt;text&gt;:1:9: unexpected &#39;==&#39; ## 1: if(2+2) == ## ^ Cela ne fonctionne pas car R évalue la première ligne et ne sait pas que vous allez utiliser une instruction else. Utilisez des accolades { } pour que R sache qu’il doit s’attendre à d’autres entrées. Essayez : if (2 + 2 == 4) { print(&quot;L&#39;arithmétique fonctionne.&quot;) } else { print(&quot;Houston, we have a problem.&quot;) } ## [1] &quot;L&#39;arithmétique fonctionne.&quot; "],["défi-1.html", "Chapter 10 Défi 1", " Chapter 10 Défi 1 Bienvenue à notre premier défi ! Pour le relever, vous utiliserez le bloc de code ci-dessous, et vous devrez : Utilisez une commande if() pour afficher “meow” si Minou est un “chat”. Utilisez une commande if() else pour afficher “woof” si un objet a la valeur “chien”, et “meow” si non. Essayez ceci sur les objets Pitou et Filou. Utilisez la fonction ifelse pour afficher “woof” pour les animaux qui sont des chiens et “meow” pour les animaux qui sont des chats. Minou &lt;- &quot;chat&quot; Pitou &lt;- &quot;chien&quot; Filou &lt;- &quot;chat&quot; animaux &lt;- c(Minou, Pitou, Filou) Voici une feuille de triche avec les opérateurs logiques qui peuvent vous aider à réaliser cet exercice : Opérateur Signification == égal à != pas égal à &lt; plus petit que &lt;= plus petit que ou égal à &gt; plus grand que &gt;= plus grand que ou égal à x&amp;y x ET y x|y x OU y isTRUE(x) est-ce que X est vrai? Solution for Challenge 1 Utilisez une commande if() pour afficher “meow” si Minou est un “chat”. if (Minou == &quot;chat&quot;) { print(&quot;meow&quot;) } ## [1] &quot;meow&quot; 2.Utilisez une commande if else pour afficher “woof” si un objet a la valeur “chien”, et “meow” si non. Essayez ceci sur les objets Pitou et Filou. x = Minou # x = Pitou if (x == &quot;chat&quot;) { print(&quot;meow&quot;) } else { print(&quot;woof&quot;) } ## [1] &quot;meow&quot; 3. Utilisez la fonction ifelse() pour afficher “woof” pour les animaux qui sont des chiens et “meow” pour les animaux qui sont des chats. animaux &lt;- c(Minou, Pitou, Filou) ifelse(animaux == &quot;chien&quot;, &quot;woof&quot;, &quot;meow&quot;) ## [1] &quot;meow&quot; &quot;woof&quot; &quot;meow&quot; or for (val in 1:3) { if (animaux[val] == &quot;chat&quot;) { print(&quot;meow&quot;) } else if (animaux[val] == &quot;chien&quot;) { print(&quot;woof&quot;) } else print(&quot;quoi?&quot;) } ## [1] &quot;meow&quot; ## [1] &quot;woof&quot; ## [1] &quot;meow&quot; "],["iteration.html", "Chapter 11 Iteration", " Chapter 11 Iteration Chaque fois que certaines opérations doivent être répétées, une boucle peut s’avérer utile. Les boucles sont utiles pour : Faire quelque chose pour chaque élément d’un objet ; Faire quelque chose jusqu’à ce que les données traitées soient épuisées ; Faire quelque chose pour chaque fichier d’un dossier ; Faire quelque chose qui peut échouer, jusqu’à ce qu’il réussisse ; L’itération d’un calcul jusqu’à ce qu’il atteigne la convergence. Ici, nous allons apprendre les types d’instructions d’itération suivants : for() {} while() {} repeat {} Nous nous plongerons également dans les fonctions de la famille apply(), qui sont des alternatives intéressantes aux boucles for() {}. Enfin, nous apprendrons à connaître deux instructions spéciales qui nous permettent de contrôler les itérations : break next "],["boucles-for.html", "Chapter 12 Boucles `for", " Chapter 12 Boucles `for Une boucle for() fonctionne de la manière suivante : for(i in sequence) { expression } La lettre i peut être remplacée par n’importe quel nom de variable, séquence peut être des éléments ou la position de ces éléments, et expression peut être n’importe quoi. Essayez les exemples ci-dessous : for (a in c(&quot;Bonjour&quot;, &quot;programmeurs et programmeuses&quot;, &quot;en R&quot;)) { print(a) } for (z in 1:4) { a &lt;- rnorm(n = 1, mean = 5 * z, sd = 2) print(a) } Output ## [1] &quot;Bonjour&quot; ## [1] &quot;programmeurs et programmeuses&quot; ## [1] &quot;en R&quot; ## [1] 7.251309 ## [1] 11.51364 ## [1] 14.1286 ## [1] 18.72144 "],["exemples-dutilisation-de-for..html", "Chapter 13 Exemples d’utilisation de for. 13.1 La boucle for simple 13.2 Boucles for sur différentes classes 13.3 for et if ensemble 13.4 for avec un jeu de données réel", " Chapter 13 Exemples d’utilisation de for. 13.1 La boucle for simple Dans l’exemple suivant, chaque instance de m est remplacée par chaque nombre entre 1 et 7, jusqu’à atteindre le dernier élément de la séquence : y &lt;- 2 for (m in 1:6) { print(y * m) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 ## [1] 12 13.2 Boucles for sur différentes classes Comme prévu, vous pouvez utiliser les boucles for() dans différents types d’objets et classes, comme une list. Prenons l’exemple ci-dessous, où nous créons la liste d’objets elements: (elements &lt;- list(a = 1:3, b = 4:10, c = 7:-1)) ## $a ## [1] 1 2 3 ## ## $b ## [1] 4 5 6 7 8 9 10 ## ## $c ## [1] 7 6 5 4 3 2 1 0 -1 Maintenant, nous allons imprimmer (print) le double de chaque élément de la liste : for (element in elements) { print(element * 2) } ## [1] 2 4 6 ## [1] 8 10 12 14 16 18 20 ## [1] 14 12 10 8 6 4 2 0 -2 13.3 for et if ensemble Effectuons des opérations pour les éléments pairs dans x en utilisant l’opérateur modulo (%%) : x &lt;- c(2, 5, 3, 9, 6) count &lt;- 0 for (val in x) { if (val%%2 == 0) { count &lt;- count + 1 } } print(count) ## [1] 2 L’exemple ci-dessus peut être représenté dans l’organigramme suivant : 13.4 for avec un jeu de données réel Les boucles for() sont souvent utilisées pour boucler sur un jeu de données. Nous allons utiliser les boucles pour exécuter des fonctions sur le jeu de données CO2 qui est construit dans R. Pour charger et voir les 6 premières lignes de la base de données CO2, exécutez le code suivant : data(CO2) # Cela charge le jeu de données intégré head(CO2) ## Plant Type Treatment ## 1 Qn1 Quebec nonchilled ## 2 Qn1 Quebec nonchilled ## 3 Qn1 Quebec nonchilled ## 4 Qn1 Quebec nonchilled ## 5 Qn1 Quebec nonchilled ## 6 Qn1 Quebec nonchilled ## conc uptake ## 1 95 16.0 ## 2 175 30.4 ## 3 250 34.8 ## 4 350 37.2 ## 5 500 35.3 ## 6 675 39.2 Now, to recursively print the CO2 concentration, let us do this: for (i in 1:length(CO2[, 1])) { # pour chaque ligne de l&#39;ensemble de données sur le CO2 print(CO2$conc[i]) # imprimer la concentration de CO2 } Voici les 40 premières réponses : ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 Maintenant, obtenons la concentration de CO2 uniquement pour les sites qui ont été échantillonnés au Québec (Canada) : for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } Here they are: ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 Indice 1. Pour boucler sur le nombre de lignes d’un cadre de données, nous pouvons utiliser la fonction nrow() : for (i in 1:nrow(CO2)) { # pour chaque ligne dans l&#39;ensemble de données sur le # CO2 print(CO2$conc[i]) # imprimer la concentration de CO2 concentration de CO2 } Indice 2. Pour effectuer des opérations sur les éléments d’une colonne, nous pouvons directement itérer sur celle-ci. for (p in CO2$conc) { # pour chaque élément de la colonne &#39;conc&#39; de le CO2 df print(p) # affiche le p-ième élément } Indice 3. L’expression à l’intérieur de la boucle peut être presque n’importe quoi et est généralement une instruction composée contenant plusieurs commandes. for (i in 4:5) { # pour i entre 4 et 5 print(colnames(CO2)[i]) print(mean(CO2[, i])) # imprime la moyenne de cette colonne à partir de l&#39;ensemble de données sur le CO2 } "],["boucles-for-dans-des-boucles-for..html", "Chapter 14 Boucles “for” dans des boucles “for”.", " Chapter 14 Boucles “for” dans des boucles “for”. Dans certains cas, vous pouvez vouloir utiliser des boucles imbriquées pour accomplir une tâche. Lorsque vous utilisez des boucles imbriquées, il est important d’utiliser des variables différentes pour chacune de vos boucles. Dans l’exemple ci-dessous, nous avons utilisé un cadre for imbriqué qui a imprimé le produit de i et n, où n faisait partie du for imbriqué et était une séquence de 1 à 3, et ensuite i, qui était également une séquence de 1 à 3, faisait partie de la boucle externe. for (i in 1:3) { for (n in 1:3) { print(i * n) } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 3 ## [1] 6 ## [1] 9 Concrètement, l’opération ci-dessus se déroule comme suit : i prend la première valeur de 1 à 3, i.e. \\(i = 1\\) ; n\" prend la première valeur de “1” à “3”, c’est-à-dire. \\(n = 1\\) ; Le produit de la valeur actuelle de i et n est calculé et imprimé, c’est-à-dire \\(i \\times n = 1 \\times 1 = 1\\) ; n prend la deuxième valeur de 1 à 3, i.e. \\(n = 2\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 1 \\times 2 = 2\\) ; n prend la troisième valeur de 1 à 3, i.e. \\(n = 3\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e*. \\(i \\times n = 1 \\times 3 = 3\\) ; i prend la deuxième valeur de 1 à 3, c’est-à-dire. \\(i = 2\\) ; Le produit de la valeur courante de i et de n est calculé et imprimé, c’est-à-dire \\(i \\times n = 2 \\times 1 = 2\\) ; n prend la deuxième valeur de 1 à 3, i.e. \\(n = 2\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 2 \\times 2 = 4\\) ; n prend la troisième valeur de 1 à 3, i.e. \\(n = 3\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 2 \\times 3 = 6\\) ; Seriez-vous capable de suivre le reste de l’itération ? "],["la-famille-des-fonctions-apply..html", "Chapter 15 La famille des fonctions apply(). 15.1 apply() 15.2 lapply() 15.3 sapply() 15.4 mapply() 15.5 tapply()", " Chapter 15 La famille des fonctions apply(). R dispose de la famille de fonctions apply(), qui consiste en des fonctions itératives qui visent à minimiser votre besoin de créer explicitement des boucles. 15.1 apply() Considérons que nous avons une matrice height contenant la hauteur (en mètres) qui a été prise sur cinq individus (en lignes) à quatre moments différents (en colonnes). (height &lt;- matrix(runif(20, 1.5, 2), nrow = 5, ncol = 4)) ## [,1] [,2] ## [1,] 1.691396 1.861329 ## [2,] 1.777942 1.895174 ## [3,] 1.953130 1.983252 ## [4,] 1.679086 1.707914 ## [5,] 1.741854 1.642045 ## [,3] [,4] ## [1,] 1.992518 1.996868 ## [2,] 1.805761 1.936988 ## [3,] 1.881694 1.908409 ## [4,] 1.754626 1.563224 ## [5,] 1.999025 1.578285 Nous aimerions obtenir la hauteur moyenne à chaque pas de temps. Une option consiste à utiliser une boucle for() {} pour itérer de la colonne 1 à 4, utiliser la fonction mean() pour calculer la moyenne des valeurs, et stocker séquentiellement la valeur de sortie dans un vecteur. On peut aussi utiliser la fonction apply() pour qu’elle applique la fonction mean() à chaque colonne de la matrice height. Voir l’exemple ci-dessous : apply(X = height, MARGIN = 2, FUN = mean) ## [1] 1.768682 1.817942 1.886725 ## [4] 1.796755 La fonction apply() commence avec trois arguments principaux : X, qui prendra une matrice ou un cadre de données ; FUN, qui peut être n’importe quelle fonction qui sera appliquée aux MARGINs de X ; et MARGIN qui prendra 1 pour les calculs en ligne, ou 2 pour les calculs en colonne. 15.2 lapply() lapply() applique une fonction à chaque élément d’une liste (list). La sortie retournée est aussi une liste (ce qui explique le “l” de lapply) et a le même nombre d’éléments que l’objet qui lui est passé. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list lapply(X = SimulatedData, FUN = mean) ## $SimpleSequence ## [1] 2.5 ## ## $Norm10 ## [1] -0.3972813 ## ## $Norm20 ## [1] 1.01914 ## ## $Norm100 ## [1] 4.987916 Les opérations lapply() effectuées dans des objets différents d’une list seront converties en list via base::as.list(). 15.3 sapply() sapply() est une fonction ‘enveloppante’ pour lapply(), mais retourne une sortie simplifiée sous forme de vecteur (vector), au lieu d’une liste (list). SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list sapply(SimulatedData, mean) ## SimpleSequence Norm10 ## 2.5000000 0.1311853 ## Norm20 Norm100 ## 1.2072686 5.0339621 15.4 mapply() mapply() fonctionne comme une version multivariée de sapply(). Il appliquera une fonction donnée au premier élément de chaque argument d’abord, puis au deuxième élément, et ainsi de suite. Par exemple : lilySeeds &lt;- c(80, 65, 89, 23, 21) poppySeeds &lt;- c(20, 35, 11, 77, 79) # Output mapply(sum, lilySeeds, poppySeeds) ## [1] 100 100 100 100 100 15.5 tapply() tapply() est utilisé pour appliquer une fonction sur des sous-ensembles d’un vecteur. Elle est principalement utilisée lorsque l’ensemble de données contient des groupes différents (i.e. niveaux/facteurs) et que nous voulons appliquer une fonction à chacun de ces groupes. head(mtcars) ## mpg cyl ## Mazda RX4 21.0 6 ## Mazda RX4 Wag 21.0 6 ## Datsun 710 22.8 4 ## Hornet 4 Drive 21.4 6 ## Hornet Sportabout 18.7 8 ## Valiant 18.1 6 ## disp hp ## Mazda RX4 160 110 ## Mazda RX4 Wag 160 110 ## Datsun 710 108 93 ## Hornet 4 Drive 258 110 ## Hornet Sportabout 360 175 ## Valiant 225 105 ## drat wt ## Mazda RX4 3.90 2.620 ## Mazda RX4 Wag 3.90 2.875 ## Datsun 710 3.85 2.320 ## Hornet 4 Drive 3.08 3.215 ## Hornet Sportabout 3.15 3.440 ## Valiant 2.76 3.460 ## qsec vs am ## Mazda RX4 16.46 0 1 ## Mazda RX4 Wag 17.02 0 1 ## Datsun 710 18.61 1 1 ## Hornet 4 Drive 19.44 1 0 ## Hornet Sportabout 17.02 0 0 ## Valiant 20.22 1 0 ## gear carb ## Mazda RX4 4 4 ## Mazda RX4 Wag 4 4 ## Datsun 710 4 1 ## Hornet 4 Drive 3 1 ## Hornet Sportabout 3 2 ## Valiant 3 1 # get the mean hp by cylinder groups tapply(mtcars$hp, mtcars$cyl, FUN = mean) ## 4 6 8 ## 82.63636 122.28571 209.21429 "],["défi-2.html", "Chapter 16 Défi 2", " Chapter 16 Défi 2 Vous avez réalisé que votre outil de mesure de l’absorption n’a pas été calibré correctement sur les sites du Québec et que toutes les mesures sont supérieures de 2 unités à ce qu’elles devraient être. Utilisez une boucle pour corriger ces mesures pour tous les sites du Québec. Utiliser une méthode basée sur la vectorisation pour calculer l’absorption moyenne de \\(CO_2\\) dans les deux zones. Pour cela, vous devez charger le jeu de données \\(\\text{CO}_{2}\\) en utilisant data(CO2), puis utiliser l’objet CO2. Solution pour le Défi 2 1.- Utilisation de for et if pour corriger les mesures : for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$uptake[i] &lt;- CO2$uptake[i] - 2 } } 2.- Utilisez tapply() pour calculer la moyenne de chaque groupe: tapply(CO2$uptake, CO2$Type, mean) ## Quebec Mississippi ## 31.54286 20.88333 "],["modifier-les-itérations-breaknext-et-while..html", "Chapter 17 Modifier les itérations : break',next’ et `while’. 17.1 next 17.2 break", " Chapter 17 Modifier les itérations : break',next’ et `while’. En R, une séquence de boucles standard peut être modifiée avec les instructions break, next et while. 17.1 next next nous permet de sauter une itération si une certaine condition est remplie. Elle est utilisée à l’intérieur de la boucle et est généralement jointe à l’instruction if, comme indiqué ci-dessous : for (val in x) { if (condition) { next } statement } 17.2 break L’instruction break est utilisée à l’intérieur d’une boucle pour terminer et quitter l’itération lorsqu’une certaine condition est remplie. for (val in x) { if (condition) { break } statement } "],["boucles-repeat.html", "Chapter 18 Boucles `repeat", " Chapter 18 Boucles `repeat Une boucle repeat effectue une opération jusqu’à ce qu’elle soit délibérément arrêtée. On peut soit utiliser Escape pour l’arrêter, ou plus adéquatement, utiliser break. repeat { expression if { condition } break } If you attempt to run the following chunk of code using repeat, it will display the result until you press Escape. repeat { print(&quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot;) } [1] &quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot; [1] &quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot; ... ... [1] &quot;Appuie sur &#39;Esc&#39; pour m&#39;arrêter !&quot; "],["les-boucles-while..html", "Chapter 19 Les boucles while.", " Chapter 19 Les boucles while. Dans la boucle while, une expression se produit pendant qu’une condition est remplie. while (condition) { expression } "],["exemples-avec-des-instructions-modifiées.html", "Chapter 20 Exemples avec des instructions modifiées", " Chapter 20 Exemples avec des instructions modifiées Nous pouvons imprimer les concentrations de \\(\\text{CO}_{2}\\) pour les traitements chilled et compter le nombre de réplications en utilisant next. count &lt;- 0 for (i in 1:nrow(CO2)) { if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # Skip to next iteration if treatment is nonchilled count &lt;- count + 1 # print(CO2$conc[i]) # You can turn this on if you want # to } print(count) # The count and print command were performed 42 times. ## [1] 42 sum(CO2$Treatment == &quot;chilled&quot;) ## [1] 42 Nous aurions également pu écrire l’exemple ci-dessus en utilisant repeat et break : count &lt;- 0 i &lt;- 0 repeat { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) if (i == nrow(CO2)) break # stop looping } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 Enfin, on aurait pu aussi faire cela en utilisant une boucle while : i &lt;- 0 count &lt;- 0 while (i &lt; nrow(CO2)) { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 "],["défi-3.html", "Chapter 21 Défi 3", " Chapter 21 Défi 3 Vous avez réalisé qu’un autre de vos outils ne fonctionnait pas correctement ! Sur les sites du Mississippi, les concentrations inférieures à 300 étaient mesurées correctement, mais les concentrations égales ou supérieures à 300 étaient surestimées de 20 unités ! Votre mission est d’utiliser une boucle pour corriger ces mesures pour tous les sites du Mississippi. Indice. Assurez-vous de recharger les données de \\(\\text{CO}_{2}\\) afin que nous travaillions avec les données brutes pour le reste de l’exercice : data(CO2) Solution pour le défi 3 Défi 3 : Réponse for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot;) { if (CO2$conc[i] &lt; 300) next CO2$conc[i] &lt;- CO2$conc[i] - 20 } } Nous aurions également pu l’écrire de cette façon, qui est plus concise et plus claire. for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot; &amp;&amp; CO2$conc[i] &gt;= 300) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } "],["modifier-un-graphique-en-utilisant-for-et-if..html", "Chapter 22 Modifier un graphique en utilisant for et if.", " Chapter 22 Modifier un graphique en utilisant for et if. Représentons l’absorption envers la concentration avec des points de couleurs différentes selon leur type (Québec ou Mississippi) et leur traitement (réfrigéré ou non). plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;) } if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;orange&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;green&quot;) } } "],["défi-4.html", "Chapter 23 Défi 4", " Chapter 23 Défi 4 Générez un graphique de comparaison de la concentration de CO2 versus l’absorption où chaque plante est représentée en utilisant un point différent. Points bonus pour avoir réalisé ce défi en utilisant des boucles imbriquées ! Solution for Challenge 4 Challenge 4: Answer plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 Concentration&quot;, ylab = &quot;CO2 Uptake&quot;) plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } "],["writing-functions.html", "Chapter 24 Writing functions", " Chapter 24 Writing functions Imagine that we would like to rescale variables to the range of 0 to 1. # our.dataset has 4 variables our.dataset &lt;- data.frame(a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10)) The equation for rescaling variables into the simplex (0-1) is: \\[x_{\\text{new}} = \\frac{x_i - \\text{min}(x)}{ \\text{max}(x) - \\text{min}(x)}\\] We could rescale these four variables to 0 and 1 by doing the following: our.dataset$a &lt;- (our.dataset$a - min(our.dataset$a, na.rm = TRUE))/(max(our.dataset$a, na.rm = TRUE) - min(our.dataset$a, na.rm = TRUE)) our.dataset$b &lt;- (our.dataset$b - min(our.dataset$b, na.rm = TRUE))/(max(our.dataset$b, na.rm = TRUE) - min(our.dataset$a, na.rm = TRUE)) our.dataset$c &lt;- (our.dataset$c - min(our.dataset$c, na.rm = TRUE))/(max(our.dataset$c, na.rm = TRUE) - min(our.dataset$c, na.rm = TRUE)) our.dataset$d &lt;- (our.dataset$d - min(our.dataset$d, na.rm = TRUE))/(max(our.dataset$d, na.rm = TRUE) - min(our.dataset$d, na.rm = TRUE)) What if our dataset had 31 variables? Repeating that equation and this chunk of code 31 times could become a tedious and inneficient process: our.dataset$a &lt;- (our.dataset$a - min(our.dataset$a, na.rm = TRUE))/(max(our.dataset$a, na.rm = TRUE) - min(our.dataset$a, na.rm = TRUE)) But, we can see that, except from the input, the code was practically the same among the variables The function here was deliberately hidden to not cause confusion among the participants # our secret hidden function rescale01(our.dataset$a) rescale01(our.dataset$b) rescale01(our.dataset$c) rescale01(our.dataset$d) "],["why-write-functions.html", "Chapter 25 Why write functions?", " Chapter 25 Why write functions? Much of the heavy lifting in R is done by functions. They are useful for: 1- Performing a task repeatedly, but configurably; 2- Making your code more readable; 3- Make your code easier to modify and maintain; 4- Sharing code between different analyses; 5- Sharing code with other people; 6- Modifying R’s built-in functionality. "],["syntax-of-a-function-function.html", "Chapter 26 Syntax of a function: function() 26.1 Arguments of a function() 26.2 Default argument values in a function 26.3 The ellipsis argument: ... 26.4 Return values 26.5 Return values 26.6 Challenge", " Chapter 26 Syntax of a function: function() function_name &lt;- function(argument1, argument2, ...) { body # What we want the function to do return(values) # Optional } function_name is the name of the function, and will be stored in the R environemnt as an object with this name; arguments take the defined values that can be used within the function; body contains the statements that define what the function does; output contains the returned value from the function. If return() is absent, then the last expression is returned. 26.1 Arguments of a function() function_name &lt;- function(argument1, argument2, ...) { body # What we want the function to do return(values) # Optional } Arguments are the input values of your function and will have the information your function needs to be able to perform correctly. A function can have between zero and an infinity of arguments. See the following example: operations &lt;- function(number1, number2, number3) { result &lt;- (number1 + number2) * number3 print(result) } operations(1, 2, 3) ## [1] 9 Challenge 4 Using what you learned previously on flow control, create a function print_animal() that takes an animal as argument and gives the following results: Scruffy &lt;- &quot;dog&quot; Paws &lt;- &quot;cat&quot; print_animal(Scruffy) ## [1] &quot;woof&quot; print_animal(Paws) ## [1] &quot;meow&quot; Challenge 4: Solution Using what you learned previously on flow control, create a function print_animal() that takes an animal as argument and gives the following results: Scruffy &lt;- &quot;dog&quot; Paws &lt;- &quot;cat&quot; print_animal(Scruffy) ## [1] &quot;woof&quot; print_animal(Paws) ## [1] &quot;meow&quot; print_animal &lt;- function(animal) { if (animal == &quot;dog&quot;) { print(&quot;woof&quot;) } else if (animal == &quot;cat&quot;) { print(&quot;meow&quot;) } } 26.2 Default argument values in a function Arguments can be provided with a default value, or even be optional. Default values are useful when using a function with the same settings. The flexibility to depart from default values is still there, if needed. operations &lt;- function(number1, number2, number3 = 3) { result &lt;- (number1 + number2) * number3 print(result) } operations(number1 = 1, number2 = 2, number3 = 3) ## [1] 9 # is equivalent to operations(1, 2) ## [1] 9 operations(1, 2, 2) # we can still change the value of number3 if needed ## [1] 6 26.3 The ellipsis argument: ... The special argument ... allows you to pass arguments from other undefined functions, i.e. allowing for an indefinite number of arguments inputs. paste_anything_fun &lt;- function(...) { arguments &lt;- list(...) paste0(arguments) } paste_anything_fun(&quot;I&quot;, &quot;want&quot;, &quot;a break!&quot;) ## [1] &quot;I&quot; &quot;want&quot; ## [3] &quot;a break!&quot; percentages &lt;- function(x, mult = 100, ...) { percent &lt;- round(x * mult, ...) paste(percent, &quot;%&quot;, sep = &quot;&quot;) } percentages(c(0.543, 0.534, 0.466)) ## [1] &quot;54%&quot; &quot;53%&quot; &quot;47%&quot; # ?round percentages(c(0.543, 0.534, 0.466), digits = 2) ## [1] &quot;54.3%&quot; &quot;53.4%&quot; &quot;46.6%&quot; The special argument ... allows you to pass on arguments to another function used inside your function. Here we use ... to pass on arguments to plot() and points(). plot.CO2 &lt;- function(CO2, ...) { plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, ...) for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;, type = &quot;p&quot;, ...) } else if (CO2$Type[i] == &quot;Mississippi&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;, type = &quot;p&quot;, ...) } } } plot.CO2(CO2, cex.lab = 1.2, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) plot.CO2(CO2, cex.lab = 1.2, pch = 20, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) 26.4 Return values The last expression evaluated in a function becomes the return value: myfun &lt;- function(x) { if (x &lt; 10) { 0 } else { 10 } } myfun(5) ## [1] 0 myfun(15) ## [1] 10 function() itself returns the last evaluated value even without including return() 26.5 Return values .small[ It can be useful to explicitly return() if the routine should end early, jump out of the function and return a value. simplefun1 &lt;- function(x) { if (x &lt; 0) return(x) } Functions can return only a single object (and text). But this is not a limitation because you can return a list containing any number of objects. simplefun2 &lt;- function(x, y) { z &lt;- x + y return(list(result = z, x = x, y = y)) } simplefun2(1, 2) ## $result ## [1] 3 ## ## $x ## [1] 1 ## ## $y ## [1] 2 26.6 Challenge Using what you have just learned on functions and control flow, create a function named bigsum that takes two arguments a and b and: Returns \\(0\\) if the sum of a and b is strictly less than \\(50\\); Else, returns the sum of a and b. Challenge 5: Solution Using what you have just learned on functions and control flow, create a function named bigsum that takes two arguments a and b and: Returns 0 if the sum of a and b is strictly less than 50; Else, returns the sum of a and b. Answer 1 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { return(0) } else { return(result) } } Answer 2 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { 0 } else { result } } "],["accessibility-of-variables.html", "Chapter 27 Accessibility of variables 27.1 Why should I care about programming practices? 27.2 Use functions to simplify your code 27.3 Use meaningful names for functions 27.4 Use comments: # 27.5 Group exercise: Solution", " Chapter 27 Accessibility of variables It is essential to always keep in mind where your variables are, and whether they are defined and accessible: Variables defined inside a function are not accessible outside from it! Variables defined outside a function are accessible inside, and are not modified, even if they have the same name. out_val &lt;- 3 vartest &lt;- function() { in_val &lt;- 4 print(in_val) print(out_val) } vartest() ## [1] 4 ## [1] 3 in_val ## Error in eval(expr, envir, enclos): object &#39;in_val&#39; not found out_val ## [1] 3 out_val_2 ## Error in eval(expr, envir, enclos): object &#39;out_val_2&#39; not found What happens in the function club, stays in the function club. Be very careful when creating variables inside a conditional statement as the variable may never have been created and cause (sometimes unperceptible) errors. var1 &lt;- 3 vartest &lt;- function() { a &lt;- 4 # &#39;a&#39; is defined inside print(a) # print &#39;a&#39; print(var1) # print var1 } a # we cannot print &#39;a&#39; as it exists only inside the function ## [1] 18.72144 vartest() # calling vartest() will print a and var1 ## [1] 4 ## [1] 3 rm(var1) # remove var1 vartest() # calling the function again does not work anymore ## [1] 4 ## Error in print(var1): object &#39;var1&#39; not found Tip It is good practice to define variables outside the conditions and then modify their values to avoid any problems. a &lt;- 3 if (a &gt; 5) { b &lt;- 2 } a + b If you had b already assigned in your environment, with a different value, you could have had a bigger problem! # Error: object &#39;b&#39; not found 27.1 Why should I care about programming practices? It makes your life easier; It helps you achieve greater readability and makes sharing and reusing your code a lot less painful; It helps reduce the time you will spend remembering and understanding your own code. Keep a clean and nice code Proper indentation and spacing is the first step to get an easy to read code: Use spaces between and after you operators x&gt;=1&amp;x&lt;=10 is more difficult to read then x &gt;= 1 &amp; x &lt;= 10 Use consistently the same assignation operator. &lt;- is often preferred. = is OK, but do not switch all the time between the two Use brackets when using flow control statements: Inside brackets, indent by at least two spaces; Put closing brackets on a separate line, except when preceding an else statement. Define each variable on its own line. Use Cmd + I or Ctrl + I in RStudio to indent the highlighted code automatically; if ((a[x, y] &gt; 1) &amp; (a[x, y] &lt; 2)) { print(&quot;Between 1 and 2&quot;) } if ((a[x, y] &gt; 1) &amp; (a[x, y] &lt; 2)) { print(&quot;Between 1 and 2&quot;) } This code is not spaced, and therefore hard to read. All brackets are badly aligned, and it looks “messy”. a &lt;- 4 b = 3 if (a &lt; b) { if (a == 0) print(&quot;a zero&quot;) } else { if (b == 0) { print(&quot;b zero&quot;) } else print(b) } On the left, code is not spaced, nor indented. All brackets are in the same line, and it looks “messy”. On the right, it looks more organized, no? a &lt;- 4 b &lt;- 3 if (a &lt; b) { if (a == 0) { print(&quot;a zero&quot;) } } else { if (b == 0) { print(&quot;b zero&quot;) } else { print(b) } } ## [1] 3 27.2 Use functions to simplify your code Write your own function: 1. When portion of the code is repeated more than a few times in your script; 2. If only a part of the code changes and includes options for different arguments. This would also reduce the number of potential errors done by copy-pasting, and the time needed to correct them. Let’s modify the example from Challenge 3 and suppose that all \\(CO_2\\) uptake from Mississipi plants was overestimated by 20 and Quebec underestimated by 50. We could write this: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Mississippi&quot;) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$conc[i] &lt;- CO2$conc[i] + 50 } } Or this: recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$conc[i] &lt;- CO2$conc[i] + bias } } return(CO2) } newCO2 &lt;- recalibrate(CO2 = CO2, type = &quot;Mississipi&quot;, bias = -20) newCO2 &lt;- recalibrate(newCO2, &quot;Quebec&quot;, +50) 27.3 Use meaningful names for functions Same function as before, but with vague names: rc &lt;- function(c, t, b) { for (i in 1:nrow(c)) { if (c$Type[i] == t) { c$uptake[i] &lt;- c$uptake[i] + b } } return(c) } Whenever possible, avoid using names of existing R functions and variables to avoid confusion and conflits. 27.3.1 Use comments What is c and rc? That being said: Whenever possible, avoid using names of existing R functions and variables to avoid confusion and conflits. 27.4 Use comments: # .alert[Final tip]. Add comments to describe what your code does, how to use its arguments or a detailed step-by-step description of the function. # Recalibrates the CO2 dataset by modifying the CO2 uptake # concentration by a fixed amount depending on the region # of sampling. Arguments CO2: the CO2 dataset type: the # type (&#39;Mississippi&#39; or &#39;Quebec&#39;) that need to be # recalibrated bias: the amount to add or remove to the # concentration uptake recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$uptake[i] &lt;- CO2$uptake[i] + bias } } return(CO2) } Challenge 6: Group exercise Using what you learned, write an if() statement that tests whether a numeric variable x is 0. If not, it assigns \\(cos(x)/x\\) to z, otherwise it assigns \\(1\\) to z. Create a function called my_function() that takes the variable x as argument and returns z. If we assign \\(45\\), \\(20\\), and \\(0\\) to x respectively, which of the following options would represent the results? 1. \\(0.054\\), \\(0.012\\), and \\(0\\); 2. \\(0.020\\), \\(0.054\\), and \\(1\\); 3. \\(0.012\\), \\(0.020\\), and \\(1\\). In addition to this, discuss with your group about a function that you would like to create (it can or it may not be related to your research). Be prepared to briefly describe it to us! ??? This exercise should take place in breakout rooms within 10 minutes. After rejoining the main room, a poll should be opened to participants. Once you obtain the response from participants, show them the correct answer and code. You may request that one of the participants explain their answer before showing the results. 27.5 Group exercise: Solution Correct answer is option 3 ( \\(0.12\\), \\(0.20\\), and \\(1\\) ). my_function &lt;- function(x) { if (x != 0) { z &lt;- cos(x)/x } else { z &lt;- 1 } return(z) } my_function(45) ## [1] 0.01167382 my_function(20) ## [1] 0.0204041 my_function(0) ## [1] 1 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
