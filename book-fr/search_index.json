[["index.html", "Workshop 5: Programming in R QCBS R Workshop Series Préface 0.1 Code de conduite 0.2 Contributeurs et contributrices 0.3 Contribuez à la série!", " Workshop 5: Programming in R QCBS R Workshop Series Développé et entretenu par les contributeurs et les contributrices de la Série d’ateliers R du CSBQ1. 2022-11-30 22:02:17 Préface La Série d’ateliers R du CSBQ est une série de 10 ateliers qui guide les participants à travers les étapes nécessaires à l’utilisation de R pour un large éventail d’analyses statistiques pertinentes pour la recherche en biologie et en écologie. Ces ateliers en accès libre ont été créés par des membres du CSBQ, à la fois pour les membres du CSBQ et pour la communauté au sens large. Le contenu de cet atelier a été revu par plusieurs membres du CSBQ. Si vous souhaitez suggérer des modifications, veuillez contacter les coordinateurs de la série actuelle, dont la liste figure sur la page principale de Github 0.1 Code de conduite La Série d’ateliers R du CSBQ et le Symposium R du CSBQ sont des lieux dédiés à fournir un environnement accueillant et favorable à toutes les personnes, indépendamment de leurs origines ou de leur identité. Les participants, les présentateurs et les organisateurs de la série d’ateliers et d’autres activités connexes acceptent le présent code de conduite lorsqu’ils assistent à des activités liées aux ateliers. Nous ne tolérons pas les comportements irrespectueux ou qui excluent, intimident ou gênent les autres. Nous ne tolérons pas la discrimination ou le harcèlement fondés sur des caractéristiques telles que, mais sans s’y limiter, l’identité et l’expression du genre, l’orientation sexuelle, le handicap, l’apparence physique, la taille du corps, la citoyenneté, la nationalité, les origines ethniques ou sociales, la grossesse, le statut familial, les informations génétiques, la religion ou les convictions (ou l’absence de celles-ci), l’appartenance à une minorité nationale, la propriété, l’âge, l’éducation, le statut socio-économique, les choix techniques et le niveau d’expérience. Il s’applique à tous les espaces gérés par l’atelier ou affiliés à celui-ci, y compris, mais sans s’y limiter, les ateliers, les listes de diffusion et les forums en ligne tels que GitHub, Slack et Twitter. 0.1.1 Comportement attendu Tous les participants sont tenus de faire preuve de respect et de courtoisie envers les autres. Toutes les interactions doivent être professionnelles, quelle que soit la plateforme utilisée : en ligne ou en personne. Afin de favoriser un environnement d’apprentissage positif et professionnel, nous encourageons les types de comportements suivants dans tous les événements et plates-formes des ateliers : Utiliser un langage accueillant et inclusif ; Respecter les différents points de vue et expériences ; Accepter avec grâce les critiques constructives ; Se concentrer sur ce qui est le mieux pour la communauté ; Faire preuve de courtoisie et de respect envers les autres membres de la communauté. 0.1.2 Comportements inacceptables Voici quelques exemples de comportements inacceptables de la part des participants à tout événement ou plateforme d’atelier : les commentaires écrits ou verbaux qui ont pour effet d’exclure des personnes sur la base de leur appartenance à un groupe spécifique ; faire craindre à quelqu’un pour sa sécurité, par exemple en le harcelant ou en l’intimidant ; des menaces ou des propos violents dirigés contre une autre personne ; l’affichage d’images sexuelles ou violentes ; l’attention sexuelle non désirée ; les contacts physiques non consensuels ou non désirés ; des insultes ou des rabais ; les blagues sexistes, racistes, homophobes, transphobes, incapables ou d’exclusion ; l’incitation à la violence, au suicide ou à l’automutilation ; la poursuite de l’interaction (y compris la photographie ou l’enregistrement) avec une personne après qu’on - lui a demandé d’arrêter ; la publication d’une communication privée sans consentement. 0.2 Contributeurs et contributrices Cet atelier a été développé à l’origine par Johanna Bradie, Sylvain Christin, Ben Haller, and Guillaume Larocque. Depuis 2014, plusieurs membres du CSBQ ont contribué à développer et à mettre à jour cet atelier collaborativement sur une base régulière, dans le cadre du Prix d’apprentissage et de développement du Centre de science de la biodiversité du Québec. Ces membres sont: 2022 - 2021 - 2020 2019 - 2018 - 2017 2016 - 2015 - 2014 Pedro Henrique P. Braga Gabriel Muñoz Johanna Bradie Gabriel Muñoz Katherine Hébert Sylvain Christin Kate Sheridan Pedro Henrique P. Braga Ben Haller Parnian Pourtaherian Marie-Hélène Brice Guillaume Larocque Pedro Henrique P. Braga Sebastien Portalier Jacob Ziegler Zofia Taranu Cédric Frenette Dussault 0.3 Contribuez à la série! En construction. La Série d’ateliers R du CSBQ fait partie du Centre de la science de la biodiversité du Québec, et est maintenue par les coordonnateurs et les coordonnatrices de la série, et les membres étudiants diplômés, postdoctoraux et professionnels de la recherche. La liste des contributeurs et des contributrices de cet atelier sont accessibles ici↩︎ "],["objectifs-dapprentissage.html", "Chapter 1 Objectifs d’apprentissage", " Chapter 1 Objectifs d’apprentissage Cet atelier se concentre sur la programmation de base en R. Vous apprendrez à utiliser les méthodes du flux de contrôle (boucles for, fonctions de la famille if, while, repeat et apply()) pour éviter la répétition du code, faciliter l’organisation et effectuer des simulations. Vous apprendrez également à écrire vos propres fonctions, et des astuces pour programmer efficacement. Reconnaître le flux de contrôle ; Se familiariser avec les tests de conditions et les itérations ; Développer vos premières fonctions en R ; Découvrir comment accélérer votre code ; Démonstration de paquets R utiles pour les biologistes. "],["préparation-de-latelier.html", "Chapter 2 Préparation de l’atelier", " Chapter 2 Préparation de l’atelier Pour vous préparer à cet atelier, vous devez télécharger et installer les premières versions de RStudio et de R. Tout le matériel de l’atelier se trouve dans le repositoire Github de cet atelier. Cela inclut un [script R] (https://qcbsrworkshops.github.io/fr/workshop05/workshop05-fr/workshop05-fr.R), qui contient tous les morceaux de code présentés dans ce livre. Pour reproduire les diagrammes inclus dans cet atelier, vous aurez besoin du paquetage DiagrammeR. Vous pouvez l’installer et le charger avec la commande suivante : install.packages(&quot;DiagrammeR&quot;) library(DiagrammeR) Accès au matériel de l’atelier "],["introduction-au-flux-de-contrôle.html", "Chapter 3 Introduction au flux de contrôle", " Chapter 3 Introduction au flux de contrôle La base de la programmation informatique, quel que soit le langage, commence par le flux de contrôle. Le flux de contrôle (ou control flow) est l’ordre dans lequel les appels de fonction, les instructions et les instructions sont exécutés ou évalués lorsqu’un programme est en cours d’exécution. Imaginez que vous souhaitiez exécuter une opération plusieurs fois, jusqu’à ce qu’une condition soit remplie. Une option, est de réécrire le même code, en changeant une partie de la syntaxe, le nombre de fois que vous le souhaitez. Une autre solution consiste à écrire notre code en utilisant le flux de contrôle, et à iterer à travers la même opération qui évaluera et s’arrêtera jusqu’à ce qu’une certaine condition soit remplie. Cette dernière option implique généralement une forme d’écriture du code beaucoup plus courte, plus claire et moins complexe. Il est avantageux, pour tout programmeur et programmeuse, de penser en termes de flux de contrôle, et donc d’avoir des programmes structurés, car : La complexité et le temps de la tâche à accomplir sont grandement diminués ; Une structure logique signifie également que le code a une clarté accrue ; Cela facilite également la collaboration, et augmente donc la productivité. 3.0.1 Building blocks of control flow Il existe de nombreux éléments constitutifs de la programmation par flux de contrôle : Séquencement, qui exécute ou évalue quelque chose de manière séquentielle ; Sélection, qui effectue des opérations if ou à moins que certaines conditions soient remplies ; L’itération**, qui répète une opération while, until ou for un nombre déterminé de fois ; L’abstraction procédurale, qui implique une sous-routine, un appel imbriqué ; Récursion ; Concurrence, qui effectue plusieurs opérations en même temps ; Traitement des exceptions et la spéculation ; Non-déterminisme. "],["utilisation-des-diagrammes-de-flux.html", "Chapter 4 Utilisation des diagrammes de flux", " Chapter 4 Utilisation des diagrammes de flux Les diagrammes de flux de contrôle peuvent être utilisés pour planifier et représenter la structure des programmes. Les principaux éléments des organigrammes de contrôle sont : Une étape de traitement, représentée par la boîte rectangulaire ; Une étape de décision, généralement désignée par un diamant ; Les étapes de début et de fin, représentées par des rectangles à bords arrondis ; Flèches indiquant la direction et chaque étape ; Des étiquettes désignant les éléments de l’organigramme. "],["prise-de-décision.html", "Chapter 5 Prise de décision", " Chapter 5 Prise de décision Il n’est pas rare que nous souhaitions effectuer des opérations conditionnellement - ou en d’autres termes, effectuer différentes opérations en fonction du résultat d’un test de conditions souhaitées. Nous pouvons utiliser if() {}, if() {} else {} et ifelse() pour nous aider dans ce processus de sélection. "],["règle-if.html", "Chapter 6 Règle if", " Chapter 6 Règle if Dans l’exemple ci-dessous, l’expression n’est exécutée que si la condition testée est “VRAIE” (ou TRUE). if (condition) { expression } Notez que lorsque la condition est FAUSSE (FALSE), rien ne se passe et le programme passe à l’étape suivante. "],["règle-if-else.html", "Chapter 7 Règle if else", " Chapter 7 Règle if else La directive if n’effectue une opération que si une condition est remplie. Cependant, on peut être intéressé non seulement par la spécification de l’expression qui doit être effectuée lorsque la condition requise est VRAIE (TRUE), mais aussi par l’expression qui doit être effectuée lorsque la condition est FAUSSE (FALSE). Pour ce faire, nous pouvons utiliser l’instruction if() {} else {} et la fonction ifelse(). if(condition) { expression 1 } else { expression 2 } ifelse(condition, expression 1, expression 2 ) "],["décisions-à-conditions-multiples.html", "Chapter 8 Décisions à conditions multiples", " Chapter 8 Décisions à conditions multiples Alors que les opérations simples if et if else testent des conditions uniques, nous pouvons faire des opérations plus complexes, qui testent des conditions multiples. Avec la fonction ifelse(), nous pouvons tester un vecteur de conditions et/ou appliquer des fonctions uniquement sous certaines conditions. Voir les exemples ci-dessous : a &lt;- 1:10 ifelse(test = a &gt; 5, yes = &quot;oui&quot;, no = &quot;non&quot;) ## [1] &quot;non&quot; &quot;non&quot; &quot;non&quot; &quot;non&quot; ## [5] &quot;non&quot; &quot;oui&quot; &quot;oui&quot; &quot;oui&quot; ## [9] &quot;oui&quot; &quot;oui&quot; a &lt;- (-4):5 sqrt(ifelse(test = a &gt;= 0, yes = a, no = NA)) ## [1] NA NA ## [3] NA NA ## [5] 0.000000 1.000000 ## [7] 1.414214 1.732051 ## [9] 2.000000 2.236068 Alors que les instructions if() {} et if() {} else {} vous laissent avec exactement deux options, l’instruction if() {} else if() {} imbriquée vous permet d’envisager plus d’alternatives. "],["décisions-à-conditions-multiples-1.html", "Chapter 9 Décisions à conditions multiples", " Chapter 9 Décisions à conditions multiples if (test_expression1) { statement1 } else if (test_expression2) { statement2 } else if (test_expression3) { statement3 } else { statement4 } "],["attention-à-lanalyse-des-déclarations.html", "Chapter 10 Attention à l’analyse des déclarations", " Chapter 10 Attention à l’analyse des déclarations A votre avis, que se passera-t-il si nous essayons le code ci-dessous ? if(2+2) == 4 print(&quot;L&#39;arithmétique fonctionne.&quot;) else print(&quot;Houston, we have a problem.&quot;) ## Error: &lt;text&gt;:1:9: unexpected &#39;==&#39; ## 1: if(2+2) == ## ^ Cela ne fonctionne pas car R évalue la première ligne et ne sait pas que vous allez utiliser une instruction else. Utilisez des accolades { } pour que R sache qu’il doit s’attendre à d’autres entrées. Essayez : if (2 + 2 == 4) { print(&quot;L&#39;arithmétique fonctionne.&quot;) } else { print(&quot;Houston, we have a problem.&quot;) } ## [1] &quot;L&#39;arithmétique fonctionne.&quot; "],["défi-1.html", "Chapter 11 Défi 1", " Chapter 11 Défi 1 Bienvenue à notre premier défi ! Pour le relever, vous utiliserez le bloc de code ci-dessous, et vous devrez : Utilisez une commande if() pour afficher “meow” si Minou est un “chat”. Utilisez une commande if() else pour afficher “woof” si un objet a la valeur “chien”, et “meow” si non. Essayez ceci sur les objets Pitou et Filou. Utilisez la fonction ifelse pour afficher “woof” pour les animaux qui sont des chiens et “meow” pour les animaux qui sont des chats. Minou &lt;- &quot;chat&quot; Pitou &lt;- &quot;chien&quot; Filou &lt;- &quot;chat&quot; animaux &lt;- c(Minou, Pitou, Filou) Voici une feuille de triche avec les opérateurs logiques qui peuvent vous aider à réaliser cet exercice : Opérateur Signification == égal à != pas égal à &lt; plus petit que &lt;= plus petit que ou égal à &gt; plus grand que &gt;= plus grand que ou égal à x&amp;y x ET y x|y x OU y isTRUE(x) est-ce que X est vrai? Solution for Challenge 1 Utilisez une commande if() pour afficher “meow” si Minou est un “chat”. if (Minou == &quot;chat&quot;) { print(&quot;meow&quot;) } ## [1] &quot;meow&quot; 2.Utilisez une commande if else pour afficher “woof” si un objet a la valeur “chien”, et “meow” si non. Essayez ceci sur les objets Pitou et Filou. x = Minou # x = Pitou if (x == &quot;chat&quot;) { print(&quot;meow&quot;) } else { print(&quot;woof&quot;) } ## [1] &quot;meow&quot; 3. Utilisez la fonction ifelse() pour afficher “woof” pour les animaux qui sont des chiens et “meow” pour les animaux qui sont des chats. animaux &lt;- c(Minou, Pitou, Filou) ifelse(animaux == &quot;chien&quot;, &quot;woof&quot;, &quot;meow&quot;) ## [1] &quot;meow&quot; &quot;woof&quot; &quot;meow&quot; or for (val in 1:3) { if (animaux[val] == &quot;chat&quot;) { print(&quot;meow&quot;) } else if (animaux[val] == &quot;chien&quot;) { print(&quot;woof&quot;) } else print(&quot;quoi?&quot;) } ## [1] &quot;meow&quot; ## [1] &quot;woof&quot; ## [1] &quot;meow&quot; "],["iteration.html", "Chapter 12 Iteration", " Chapter 12 Iteration Chaque fois que certaines opérations doivent être répétées, une boucle peut s’avérer utile. Les boucles sont utiles pour : Faire quelque chose pour chaque élément d’un objet ; Faire quelque chose jusqu’à ce que les données traitées soient épuisées ; Faire quelque chose pour chaque fichier d’un dossier ; Faire quelque chose qui peut échouer, jusqu’à ce qu’il réussisse ; L’itération d’un calcul jusqu’à ce qu’il atteigne la convergence. Ici, nous allons apprendre les types d’instructions d’itération suivants : for() {} while() {} repeat {} Nous nous plongerons également dans les fonctions de la famille apply(), qui sont des alternatives intéressantes aux boucles for() {}. Enfin, nous apprendrons à connaître deux instructions spéciales qui nous permettent de contrôler les itérations : break next "],["boucles-for.html", "Chapter 13 Boucles `for", " Chapter 13 Boucles `for Une boucle for() fonctionne de la manière suivante : for(i in sequence) { expression } La lettre i peut être remplacée par n’importe quel nom de variable, séquence peut être des éléments ou la position de ces éléments, et expression peut être n’importe quoi. Essayez les exemples ci-dessous : for (a in c(&quot;Bonjour&quot;, &quot;programmeurs et programmeuses&quot;, &quot;en R&quot;)) { print(a) } for (z in 1:4) { a &lt;- rnorm(n = 1, mean = 5 * z, sd = 2) print(a) } Output ## [1] &quot;Bonjour&quot; ## [1] &quot;programmeurs et programmeuses&quot; ## [1] &quot;en R&quot; ## [1] 4.43757 ## [1] 7.756069 ## [1] 10.07945 ## [1] 19.47551 "],["exemples-dutilisation-de-for..html", "Chapter 14 Exemples d’utilisation de for. 14.1 La boucle for simple 14.2 Boucles for sur différentes classes 14.3 for et if ensemble 14.4 for avec un jeu de données réel", " Chapter 14 Exemples d’utilisation de for. 14.1 La boucle for simple Dans l’exemple suivant, chaque instance de m est remplacée par chaque nombre entre 1 et 7, jusqu’à atteindre le dernier élément de la séquence : y &lt;- 2 for (m in 1:6) { print(y * m) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 ## [1] 12 14.2 Boucles for sur différentes classes Comme prévu, vous pouvez utiliser les boucles for() dans différents types d’objets et classes, comme une list. Prenons l’exemple ci-dessous, où nous créons la liste d’objets elements: (elements &lt;- list(a = 1:3, b = 4:10, c = 7:-1)) ## $a ## [1] 1 2 3 ## ## $b ## [1] 4 5 6 7 8 9 10 ## ## $c ## [1] 7 6 5 4 3 2 1 0 -1 Maintenant, nous allons imprimmer (print) le double de chaque élément de la liste : for (element in elements) { print(element * 2) } ## [1] 2 4 6 ## [1] 8 10 12 14 16 18 20 ## [1] 14 12 10 8 6 4 2 0 -2 14.3 for et if ensemble Effectuons des opérations pour les éléments pairs dans x en utilisant l’opérateur modulo (%%) : x &lt;- c(2, 5, 3, 9, 6) count &lt;- 0 for (val in x) { if (val%%2 == 0) { count &lt;- count + 1 } } print(count) ## [1] 2 L’exemple ci-dessus peut être représenté dans l’organigramme suivant : 14.4 for avec un jeu de données réel Les boucles for() sont souvent utilisées pour boucler sur un jeu de données. Nous allons utiliser les boucles pour exécuter des fonctions sur le jeu de données CO2 qui est construit dans R. Pour charger et voir les 6 premières lignes de la base de données CO2, exécutez le code suivant : data(CO2) # Cela charge le jeu de données intégré head(CO2) ## Plant Type Treatment ## 1 Qn1 Quebec nonchilled ## 2 Qn1 Quebec nonchilled ## 3 Qn1 Quebec nonchilled ## 4 Qn1 Quebec nonchilled ## 5 Qn1 Quebec nonchilled ## 6 Qn1 Quebec nonchilled ## conc uptake ## 1 95 16.0 ## 2 175 30.4 ## 3 250 34.8 ## 4 350 37.2 ## 5 500 35.3 ## 6 675 39.2 Now, to recursively print the CO2 concentration, let us do this: for (i in 1:length(CO2[, 1])) { # pour chaque ligne de l&#39;ensemble de données sur le CO2 print(CO2$conc[i]) # imprimer la concentration de CO2 } Voici les 40 premières réponses : ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 Maintenant, obtenons la concentration de CO2 uniquement pour les sites qui ont été échantillonnés au Québec (Canada) : for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } for (i in 1:length(CO2[, 1])) { # for each row in the CO2 dataset if the type is # &#39;Quebec&#39; if (CO2$Type[i] == &quot;Quebec&quot;) { print(CO2$conc[i]) # print the CO2 concentration } } Here they are: ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 Indice 1. Pour boucler sur le nombre de lignes d’un cadre de données, nous pouvons utiliser la fonction nrow() : for (i in 1:nrow(CO2)) { # pour chaque ligne dans l&#39;ensemble de données sur le # CO2 print(CO2$conc[i]) # imprimer la concentration de CO2 concentration de CO2 } Indice 2. Pour effectuer des opérations sur les éléments d’une colonne, nous pouvons directement itérer sur celle-ci. for (p in CO2$conc) { # pour chaque élément de la colonne &#39;conc&#39; de le CO2 df print(p) # affiche le p-ième élément } Indice 3. L’expression à l’intérieur de la boucle peut être presque n’importe quoi et est généralement une instruction composée contenant plusieurs commandes. for (i in 4:5) { # pour i entre 4 et 5 print(colnames(CO2)[i]) print(mean(CO2[, i])) # imprime la moyenne de cette colonne à partir de l&#39;ensemble de données sur le CO2 } "],["boucles-for-dans-des-boucles-for..html", "Chapter 15 Boucles “for” dans des boucles “for”.", " Chapter 15 Boucles “for” dans des boucles “for”. Dans certains cas, vous pouvez vouloir utiliser des boucles imbriquées pour accomplir une tâche. Lorsque vous utilisez des boucles imbriquées, il est important d’utiliser des variables différentes pour chacune de vos boucles. Dans l’exemple ci-dessous, nous avons utilisé un cadre for imbriqué qui a imprimé le produit de i et n, où n faisait partie du for imbriqué et était une séquence de 1 à 3, et ensuite i, qui était également une séquence de 1 à 3, faisait partie de la boucle externe. for (i in 1:3) { for (n in 1:3) { print(i * n) } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 3 ## [1] 6 ## [1] 9 Concrètement, l’opération ci-dessus se déroule comme suit : i prend la première valeur de 1 à 3, i.e. \\(i = 1\\) ; n\" prend la première valeur de “1” à “3”, c’est-à-dire. \\(n = 1\\) ; Le produit de la valeur actuelle de i et n est calculé et imprimé, c’est-à-dire \\(i \\times n = 1 \\times 1 = 1\\) ; n prend la deuxième valeur de 1 à 3, i.e. \\(n = 2\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 1 \\times 2 = 2\\) ; n prend la troisième valeur de 1 à 3, i.e. \\(n = 3\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e*. \\(i \\times n = 1 \\times 3 = 3\\) ; i prend la deuxième valeur de 1 à 3, c’est-à-dire. \\(i = 2\\) ; Le produit de la valeur courante de i et de n est calculé et imprimé, c’est-à-dire \\(i \\times n = 2 \\times 1 = 2\\) ; n prend la deuxième valeur de 1 à 3, i.e. \\(n = 2\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 2 \\times 2 = 4\\) ; n prend la troisième valeur de 1 à 3, i.e. \\(n = 3\\) ; Le produit de la valeur courante de i et n est calculé et imprimé, i.e. \\(i \\times n = 2 \\times 3 = 6\\) ; Seriez-vous capable de suivre le reste de l’itération ? "],["la-famille-des-fonctions-apply..html", "Chapter 16 La famille des fonctions apply(). 16.1 apply() 16.2 lapply() 16.3 sapply() 16.4 mapply() 16.5 tapply()", " Chapter 16 La famille des fonctions apply(). R dispose de la famille de fonctions apply(), qui consiste en des fonctions itératives qui visent à minimiser votre besoin de créer explicitement des boucles. 16.1 apply() Considérons que nous avons une matrice height contenant la hauteur (en mètres) qui a été prise sur cinq individus (en lignes) à quatre moments différents (en colonnes). (height &lt;- matrix(runif(20, 1.5, 2), nrow = 5, ncol = 4)) ## [,1] [,2] ## [1,] 1.698698 1.884037 ## [2,] 1.871205 1.532767 ## [3,] 1.581049 1.973575 ## [4,] 1.916005 1.812683 ## [5,] 1.834803 1.761478 ## [,3] [,4] ## [1,] 1.776821 1.582440 ## [2,] 1.561942 1.946515 ## [3,] 1.697060 1.528281 ## [4,] 1.902023 1.673909 ## [5,] 1.949152 1.624189 Nous aimerions obtenir la hauteur moyenne à chaque pas de temps. Une option consiste à utiliser une boucle for() {} pour itérer de la colonne 1 à 4, utiliser la fonction mean() pour calculer la moyenne des valeurs, et stocker séquentiellement la valeur de sortie dans un vecteur. On peut aussi utiliser la fonction apply() pour qu’elle applique la fonction mean() à chaque colonne de la matrice height. Voir l’exemple ci-dessous : apply(X = height, MARGIN = 2, FUN = mean) ## [1] 1.780352 1.792908 1.777400 ## [4] 1.671067 La fonction apply() commence avec trois arguments principaux : X, qui prendra une matrice ou un cadre de données ; FUN, qui peut être n’importe quelle fonction qui sera appliquée aux MARGINs de X ; et MARGIN qui prendra 1 pour les calculs en ligne, ou 2 pour les calculs en colonne. 16.2 lapply() lapply() applique une fonction à chaque élément d’une liste (list). La sortie retournée est aussi une liste (ce qui explique le “l” de lapply) et a le même nombre d’éléments que l’objet qui lui est passé. SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list lapply(X = SimulatedData, FUN = mean) ## $SimpleSequence ## [1] 2.5 ## ## $Norm10 ## [1] -0.4106907 ## ## $Norm20 ## [1] 1.133473 ## ## $Norm100 ## [1] 5.104022 Les opérations lapply() effectuées dans des objets différents d’une list seront converties en list via base::as.list(). 16.3 sapply() sapply() est une fonction ‘enveloppante’ pour lapply(), mais retourne une sortie simplifiée sous forme de vecteur (vector), au lieu d’une liste (list). SimulatedData &lt;- list(SimpleSequence = 1:4, Norm10 = rnorm(10), Norm20 = rnorm(20, 1), Norm100 = rnorm(100, 5)) # Apply mean to each element of the list sapply(SimulatedData, mean) ## SimpleSequence Norm10 ## 2.5000000 -0.1572534 ## Norm20 Norm100 ## 1.1868906 5.0145262 16.4 mapply() mapply() fonctionne comme une version multivariée de sapply(). Il appliquera une fonction donnée au premier élément de chaque argument d’abord, puis au deuxième élément, et ainsi de suite. Par exemple : lilySeeds &lt;- c(80, 65, 89, 23, 21) poppySeeds &lt;- c(20, 35, 11, 77, 79) # Output mapply(sum, lilySeeds, poppySeeds) ## [1] 100 100 100 100 100 16.5 tapply() tapply() est utilisé pour appliquer une fonction sur des sous-ensembles d’un vecteur. Elle est principalement utilisée lorsque l’ensemble de données contient des groupes différents (i.e. niveaux/facteurs) et que nous voulons appliquer une fonction à chacun de ces groupes. head(mtcars) ## mpg cyl ## Mazda RX4 21.0 6 ## Mazda RX4 Wag 21.0 6 ## Datsun 710 22.8 4 ## Hornet 4 Drive 21.4 6 ## Hornet Sportabout 18.7 8 ## Valiant 18.1 6 ## disp hp ## Mazda RX4 160 110 ## Mazda RX4 Wag 160 110 ## Datsun 710 108 93 ## Hornet 4 Drive 258 110 ## Hornet Sportabout 360 175 ## Valiant 225 105 ## drat wt ## Mazda RX4 3.90 2.620 ## Mazda RX4 Wag 3.90 2.875 ## Datsun 710 3.85 2.320 ## Hornet 4 Drive 3.08 3.215 ## Hornet Sportabout 3.15 3.440 ## Valiant 2.76 3.460 ## qsec vs am ## Mazda RX4 16.46 0 1 ## Mazda RX4 Wag 17.02 0 1 ## Datsun 710 18.61 1 1 ## Hornet 4 Drive 19.44 1 0 ## Hornet Sportabout 17.02 0 0 ## Valiant 20.22 1 0 ## gear carb ## Mazda RX4 4 4 ## Mazda RX4 Wag 4 4 ## Datsun 710 4 1 ## Hornet 4 Drive 3 1 ## Hornet Sportabout 3 2 ## Valiant 3 1 # get the mean hp by cylinder groups tapply(mtcars$hp, mtcars$cyl, FUN = mean) ## 4 6 8 ## 82.63636 122.28571 209.21429 "],["défi-2.html", "Chapter 17 Défi 2", " Chapter 17 Défi 2 Vous avez réalisé que votre outil de mesure de l’absorption n’a pas été calibré correctement sur les sites du Québec et que toutes les mesures sont supérieures de 2 unités à ce qu’elles devraient être. Utilisez une boucle pour corriger ces mesures pour tous les sites du Québec. Utiliser une méthode basée sur la vectorisation pour calculer l’absorption moyenne de \\(CO_2\\) dans les deux zones. Pour cela, vous devez charger le jeu de données \\(\\text{CO}_{2}\\) en utilisant data(CO2), puis utiliser l’objet CO2. Solution pour le Défi 2 1.- Utilisation de for et if pour corriger les mesures : for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$uptake[i] &lt;- CO2$uptake[i] - 2 } } 2.- Utilisez tapply() pour calculer la moyenne de chaque groupe: tapply(CO2$uptake, CO2$Type, mean) ## Quebec Mississippi ## 31.54286 20.88333 "],["modifier-les-itérations-breaknext-et-while..html", "Chapter 18 Modifier les itérations : break',next’ et `while’. 18.1 next 18.2 break", " Chapter 18 Modifier les itérations : break',next’ et `while’. En R, une séquence de boucles standard peut être modifiée avec les instructions break, next et while. 18.1 next next nous permet de sauter une itération si une certaine condition est remplie. Elle est utilisée à l’intérieur de la boucle et est généralement jointe à l’instruction if, comme indiqué ci-dessous : for (val in x) { if (condition) { next } statement } 18.2 break L’instruction break est utilisée à l’intérieur d’une boucle pour terminer et quitter l’itération lorsqu’une certaine condition est remplie. for (val in x) { if (condition) { break } statement } "],["boucles-repeat.html", "Chapter 19 Boucles `repeat", " Chapter 19 Boucles `repeat Une boucle repeat effectue une opération jusqu’à ce qu’elle soit délibérément arrêtée. On peut soit utiliser Escape pour l’arrêter, ou plus adéquatement, utiliser break. repeat { expression if { condition } break } If you attempt to run the following chunk of code using repeat, it will display the result until you press Escape. repeat { print(&quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot;) } [1] &quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot; [1] &quot;Appuyez sur &#39;Esc&#39; pour m&#39;arrêter !&quot; ... ... [1] &quot;Appuie sur &#39;Esc&#39; pour m&#39;arrêter !&quot; "],["les-boucles-while..html", "Chapter 20 Les boucles while.", " Chapter 20 Les boucles while. Dans la boucle while, une expression se produit pendant qu’une condition est remplie. while (condition) { expression } "],["exemples-avec-des-instructions-modifiées.html", "Chapter 21 Exemples avec des instructions modifiées", " Chapter 21 Exemples avec des instructions modifiées Nous pouvons imprimer les concentrations de \\(\\text{CO}_{2}\\) pour les traitements chilled et compter le nombre de réplications en utilisant next. count &lt;- 0 for (i in 1:nrow(CO2)) { if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # Skip to next iteration if treatment is nonchilled count &lt;- count + 1 # print(CO2$conc[i]) # You can turn this on if you want # to } print(count) # The count and print command were performed 42 times. ## [1] 42 sum(CO2$Treatment == &quot;chilled&quot;) ## [1] 42 Nous aurions également pu écrire l’exemple ci-dessus en utilisant repeat et break : count &lt;- 0 i &lt;- 0 repeat { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) if (i == nrow(CO2)) break # stop looping } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 Enfin, on aurait pu aussi faire cela en utilisant une boucle while : i &lt;- 0 count &lt;- 0 while (i &lt; nrow(CO2)) { i &lt;- i + 1 if (CO2$Treatment[i] == &quot;nonchilled&quot;) next # skip this loop count &lt;- count + 1 print(CO2$conc[i]) } ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 ## [1] 95 ## [1] 175 ## [1] 250 ## [1] 350 ## [1] 500 ## [1] 675 ## [1] 1000 print(count) ## [1] 42 "],["défi-3.html", "Chapter 22 Défi 3", " Chapter 22 Défi 3 Vous avez réalisé qu’un autre de vos outils ne fonctionnait pas correctement ! Sur les sites du Mississippi, les concentrations inférieures à 300 étaient mesurées correctement, mais les concentrations égales ou supérieures à 300 étaient surestimées de 20 unités ! Votre mission est d’utiliser une boucle pour corriger ces mesures pour tous les sites du Mississippi. Indice. Assurez-vous de recharger les données de \\(\\text{CO}_{2}\\) afin que nous travaillions avec les données brutes pour le reste de l’exercice : data(CO2) Solution pour le défi 3 Défi 3 : Réponse for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot;) { if (CO2$conc[i] &lt; 300) next CO2$conc[i] &lt;- CO2$conc[i] - 20 } } Nous aurions également pu l’écrire de cette façon, qui est plus concise et plus claire. for (i in 1:nrow(CO2)) { if (CO2$Type[i] == &quot;Mississippi&quot; &amp;&amp; CO2$conc[i] &gt;= 300) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } "],["modifier-un-graphique-en-utilisant-for-et-if..html", "Chapter 23 Modifier un graphique en utilisant for et if.", " Chapter 23 Modifier un graphique en utilisant for et if. Représentons l’absorption envers la concentration avec des points de couleurs différentes selon leur type (Québec ou Mississippi) et leur traitement (réfrigéré ou non). plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;) } if (CO2$Type[i] == &quot;Quebec&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;nonchilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;orange&quot;) } if (CO2$Type[i] == &quot;Mississippi&quot; &amp; CO2$Treatment[i] == &quot;chilled&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;green&quot;) } } "],["défi-4.html", "Chapter 24 Défi 4", " Chapter 24 Défi 4 Générez un graphique de comparaison de la concentration de CO2 versus l’absorption où chaque plante est représentée en utilisant un point différent. Points bonus pour avoir réalisé ce défi en utilisant des boucles imbriquées ! Solution for Challenge 4 Challenge 4: Answer plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) # Type &#39;n&#39; tells R to not actually plot the points. plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, cex.lab = 1.4, xlab = &quot;CO2 Concentration&quot;, ylab = &quot;CO2 Uptake&quot;) plants &lt;- unique(CO2$Plant) for (i in 1:nrow(CO2)) { for (p in 1:length(plants)) { if (CO2$Plant[i] == plants[p]) { points(CO2$conc[i], CO2$uptake[i], col = p) } } } "],["écrire-des-fonctions.html", "Chapter 25 Écrire des fonctions 25.1 Pourquoi écrire une fonction ?", " Chapter 25 Écrire des fonctions 25.1 Pourquoi écrire une fonction ? Le gros du travail dans R est fait par des fonctions. Elles sont utiles pour: Répéter une même tâche, mais en changeant ses paramètres; Rendre votre code plus lisible; Rendre votre code plus facile à modifier et à maintenir; Partager du code entre différentes analyses; Partager votre code avec d’autres personnes; Modifier les fonctionnalités par défaut de R. "],["syntaxe-dune-fonction.html", "Chapter 26 Syntaxe d’une fonction 26.1 Arguments d’une fonction 26.2 Valeurs par défaut dans une fonction 26.3 Argument spécial ... 26.4 Valeurs de retour 26.5 Valeurs de retour 26.6 Exercice 6", " Chapter 26 Syntaxe d’une fonction function_name &lt;- function(argument1, argument2, ...) { expression... # Ce que la fonction fait return(valeur) # Optionnel, pour sortir le résultat de la fonction } 26.1 Arguments d’une fonction function_name &lt;- function(argument1, argument2, ...) { expression... return(valeur) } Les arguments sont les données fournies en entrée à votre fonction et contiennent l’information nécessaire pour que la fonction opère correctement. Une fonction peut avoir entre 0 et une infinité d’arguments. Par exemple: operations &lt;- function(numero_1, numero_2, numero_3) { resultat &lt;- (numero_1 + numero_2) * numero_3 print(resultat) } operations(1, 2, 3) ## [1] 9 Exercice 5 En utilisant ce que vous avez appris précédemment sur le contrôle de flux, créez une fonction print_animal() qui prend un animal comme argument et donne les résultats suivants : Pitou &lt;- &quot;chien&quot; Minou &lt;- &quot;chat&quot; print_animal(Pitou) ## [1] &quot;woof&quot; print_animal(Minou) ## [1] &quot;miaou&quot; Exercice 5: Solution Using what you learned previously on flow control, create a function print_animal() that takes an animal as argument and gives the following results: print_animal &lt;- function(animal) { if (animal == &quot;chien&quot;) { print(&quot;woof&quot;) } else if (animal == &quot;chat&quot;) { print(&quot;miaou&quot;) } } 26.2 Valeurs par défaut dans une fonction Les arguments peuvent aussi être optionnels, auquel cas on peut leur donner une valeur par défaut. Ceci peut s’avérer utile si on utilise souvent une fonction avec les mêmes paramètres, mais qu’on veut tout de même garder la possibilité de changer leur valeur si nécessaire. operations &lt;- function(numero_1, numero_2, numero_3 = 3) { resultat &lt;- (numero_1 + numero_2) * numero_3 print(resultat) } operations(1, 2, 3) # est équivalent à ## [1] 9 operations(1, 2) ## [1] 9 operations(1, 2, 2) # on peut toujours changer la valeur de numero_3 ## [1] 6 26.3 Argument spécial ... L’argument spécial ... vous permet de passer des arguments à une autre fonction utilisée à l’intérieur de votre fonction. Ici, on utilise ... pour passer des arguments à plot() et points(). plot.CO2 &lt;- function(CO2, ...) { plot(x = CO2$conc, y = CO2$uptake, type = &quot;n&quot;, ...) # On utilise ... pour passer les arguments a plot(). for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;red&quot;, type = &quot;p&quot;, ...) } else if (CO2$Type[i] == &quot;Mississippi&quot;) { points(CO2$conc[i], CO2$uptake[i], col = &quot;blue&quot;, type = &quot;p&quot;, ...) } } } plot.CO2(CO2, cex.lab = 1.2, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) plot.CO2(CO2, cex.lab = 1.2, pch = 20, xlab = &quot;CO2 concentration&quot;, ylab = &quot;CO2 uptake&quot;) L’argument spécial ... permet d’entrer un nombre indéfini d’arguments. sum2 &lt;- function(...) { args &lt;- list(...) result &lt;- 0 for (i in args) { result &lt;- result + i } return(result) } sum2(2, 3) ## [1] 5 sum2(2, 4, 5, 7688, 1) ## [1] 7700 26.4 Valeurs de retour La dernière expression évaluée dans une fonction devient la valeur de sortie. myfun &lt;- function(x) { if (x &lt; 10) { 0 } else { 10 } } myfun(5) ## [1] 0 myfun(15) ## [1] 10 function() sort la dernière valeur évaluée, même sans inclure la fonction return(). 26.5 Valeurs de retour Utiliser return() de façon explicite peut être utile si la boucle doit terminer tôt, sortir de la fonction, et sortir une valeur. simplefun1 &lt;- function(x) { if (x &lt; 0) return(x) } Un seul objet (ou texte) de retour peut être renvoyé par une fonction. Par contre, ceci n’est pas une limite: on peut renovoyer une liste contenant plusieurs objets. simplefun2 &lt;- function(x, y) { z &lt;- x + y return(list(result = z, x = x, y = y)) } simplefun2(1, 2) ## $result ## [1] 3 ## ## $x ## [1] 1 ## ## $y ## [1] 2 26.6 Exercice 6 En utilisant vos nouvelles connaissances de fonctions et de structures de contrôle, créez une fonction bigsum() qui prend 2 arguments a et b, et: Sort 0 si la somme de a et b est strictement inférieure à 50; Sinon, sort la somme de a et b. Exercice 6: Solution En utilisant vos nouvelles connaissances de fonctions et de structures de contrôle, créez une fonction bigsum() qui prend 2 arguments a et b, et: Sort 0 si la somme de a et b est strictement inférieure à 50; Sinon, sort la somme de a et b. Solution 1 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { return(0) } else { return(result) } } Solution 2 bigsum &lt;- function(a, b) { result &lt;- a + b if (result &lt; 50) { 0 } else { result } } "],["accessibilité-des-variables.html", "Chapter 27 Accessibilité des variables", " Chapter 27 Accessibilité des variables Il est essentiel de pouvoir situer nos variables, et de savoir si elles sont définies et accessibles. Les variables définies à l’intérieur d’une fonction ne sont pas accessibles à l’extérieur de la fonction! Les variables définies à l’extérieur d’une fonction sont accessibles à l’intérieur, mais ce n’est jamais une bonne idée! Votre fonction ne fonctionnera plus si la variable extérieure est effacée! Faites très attention lorsque vous créez des variables à l’intérieur d’une condition, car la variable pourrait ne jamais être créée et causer des erreurs (parfois imperceptibles). var1 &lt;- 3 # &#39;var1&#39; est définie à l&#39;extérieur de la fonction vartest &lt;- function() { a &lt;- 4 # &#39;a&#39; est définie a l&#39;intérieur print(a) # affiche &#39;a&#39; print(var1) # affiche &#39;var1&#39; } a # on ne peut pas afficher &#39;a&#39;, car &#39;a&#39; n&#39;existe qu&#39;à l&#39;intérieur de la fonction ## [1] 19.47551 vartest() # cvartest() affiche &#39;a&#39; et &#39;var1&#39; ## [1] 4 ## [1] 3 rm(var1) # supprime &#39;var1&#39; vartest() # la fonction ne fonctionne plus, car &#39;var1&#39; n&#39;existe plus! ## [1] 4 ## Error in print(var1): object &#39;var1&#39; not found Utilisez des arguments! De plus, à l’intérieur d’une fonction, les noms d’arguments remplaceront les noms des autres variables. var1 &lt;- 3 # var1 est définie à l&#39;extérieur de la fonction vartest &lt;- function(var1) { print(var1) # affiche var1 } vartest(8) # Dans notre fonction, var1 est maintenant notre argument et prend sa valeur ## [1] 8 var1 # var1 a toujours la même valeur à l&#39;extérieur de la fonction ## [1] 3 Une bonne pratique serait de définir les variables à l’extérieur de la condition, puis ensuite de modifier leurs valeurs pour éviter ces problèmes. a &lt;- 3 if (a &gt; 5) { b &lt;- 2 } a + b # Error: object &#39;b&#39; not found Si b avait déjà une valeur différente assignée dans l’environnement, on aurait un gros problème! R ne trouverait pas d’erreur, et la valeur de a + b serait entièrement différente! "],["bonnes-pratiques-de-programmation.html", "Chapter 28 Bonnes pratiques de programmation 28.1 Pourquoi devrais-je me soucier sur les bonnes pratiques de programmation? 28.2 Utilisez des fonctions pour simplifier le code 28.3 Noms de fonctions informatifs 28.4 Utilisez des commentaires: # 28.5 Exercice de groupe", " Chapter 28 Bonnes pratiques de programmation 28.1 Pourquoi devrais-je me soucier sur les bonnes pratiques de programmation? Pour vous faciliter la vie; Pour améliorer la lisibilité et faciliter le partage et la réutilisation de votre code; Pour réduire le temps que vous passeriez à essayer de comprendre votre code. Gardez un code beau et propre Les indentations et les espaces sont une première étape vers un code lisible: Utilisez des espaces avant et après vos opérateurs; x&gt;=1&amp;x&lt;=10 est plus difficile à lire que x &gt;= 1 &amp; x &lt;= 10 Utilisez toujours le même opérateur d’assignation. &lt;- est préférable. Vous pouvez utiliser = (parfois), mais ne changez pas entre les deux; Utilisez des crochets pour encadrer vos structures de contrôle de flux: À l’intérieur des crochets, faites une indentation d’au moins 2 espaces; Les crochets de fermeture occupent généralement leur propre ligne, sauf s’ils précèdent une condition else. Définissez chaque variable sur sa propre ligne; Utilisez Cmd + I ou Ctrl + I dans RStudio pour indenter automatiquement le code mis en évidence. 28.2 Utilisez des fonctions pour simplifier le code Écrivez une fonction: 1. Quand une portion du code est répété à plus de 2 reprises dans ton script; 2. Quand seulement une partie du code change et inclut des options pour différents arguments. Ceci vous aidera à réduire le nombre d’erreurs de copier/coller, et réduira le temps passé à les corriger. Modifions l’exemple de l’Exercice 3 et supposons que toutes les concentrations de \\(CO_2\\) du Mississipi étaient surestimées de 20 et que celles du Québec étaient sous-estimées de 50. On pourrait écrire ceci: for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Mississippi&quot;) { CO2$conc[i] &lt;- CO2$conc[i] - 20 } } for (i in 1:length(CO2[, 1])) { if (CO2$Type[i] == &quot;Quebec&quot;) { CO2$conc[i] &lt;- CO2$conc[i] + 50 } } Ou ceci: recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$conc[i] &lt;- CO2$conc[i] + bias } } return(CO2) } newCO2 &lt;- recalibrate(CO2 = CO2, type = &quot;Mississipi&quot;, bias = -20) newCO2 &lt;- recalibrate(newCO2, &quot;Quebec&quot;, +50) 28.3 Noms de fonctions informatifs Voici notre fonction de l’exemple précédent avec un nom vague. rc &lt;- function(c, t, b) { for (i in 1:nrow(c)) { if (c$Type[i] == t) { c$uptake[i] &lt;- c$uptake[i] + b } } return(c) } Qu-est ce que rc et c? Quand possible, évitez d’utiliser des noms de fonctions R et de variables qui existent déjà pour éviter la confusion et les conflits. 28.4 Utilisez des commentaires: # Ajoutez des commentaires pour décrire tout ce que votre code fait, que ce soit le but de la fonction, comment utiliser ses arguments, ou une description détaillée de la fonction étape par étape. # Recalibre le jeu de données CO2 en modifiant la # concentration de CO2 d&#39;une valeur fixe selon la region # Arguments CO2: the CO2 dataset type: the type # (&#39;Mississippi&#39; or &#39;Quebec&#39;) that need to be recalibrated. # bias: the amount to add or remove to the concentration recalibrate &lt;- function(CO2, type, bias) { for (i in 1:nrow(CO2)) { if (CO2$Type[i] == type) { CO2$conc[i] &lt;- CO2$conc[i] + bias } } return(CO2) } 28.5 Exercice de groupe En utilisant ce que vous avez appris, écrivez une déclaration if() qui vérifie si une variable numérique x est égale à zéro. Si ce n’est pas le cas, elle attribue \\(cos(x)/x\\) à z, sinon elle attribue \\(1\\) à z. Créez une fonction appelée ma_fonction() qui prend la variable x en argument et retourne z. Si nous attribuons respectivement \\(45\\), \\(20\\) et \\(0\\) à x, laquelle des options suivantes représenterait les résultats ? 1. \\(0.054\\), \\(0.012\\), et \\(0\\); 2. \\(0.020\\), \\(0.054\\), et \\(1\\); 3. \\(0.012\\), \\(0.020\\), et \\(1\\). Exercice de groupe: Solution La bonne réponse est l’option 3 ( \\(0.012\\), \\(0.020\\) et \\(1\\) ). my_function &lt;- function(x) { if (x != 0) { z &lt;- cos(x)/x } else { z &lt;- 1 } return(z) } my_function(45) ## [1] 0.01167382 my_function(20) ## [1] 0.0204041 my_function(0) ## [1] 1 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
